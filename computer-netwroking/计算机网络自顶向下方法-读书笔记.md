#  计算机网络自顶向下方法

## 1. 计算机网络和因特网

### 1.1 什么是因特网

#### 1.1.1 具体构成描述

从因特网的组成部件角度出发：

由不同的主机（端系统）所组成的网络叫做`因特网`。其中`主机`不仅仅是桌面PC、服务器等，也可以是一些非传统设备，如：电视、游戏机、家用电器等。

端系统通过`通信链路(communication link)`和`分组交换机(packet switch)`连接到一起。

* 通信链路：不同类型的`通信链路`由不同类型的物理媒体组成，如：同轴电缆、光纤和无线电频谱。其不同`通信链路`有不同的传输速率，其以比特/秒(bit/s，或bps)度量

* 分组：当一个端系统向另外一个端系统发送数据前，发送端系统需要先将数据进行分段，并为每段加上首部字节，由此组成的信息包，叫做分组。

* 分组交换机：分组交换机从它的一条`入通信链路`接收分组，并从另外一条`出通信链路`转发该分组。常见的有`路由器(router)`和`链路层交换机(link-layer switch)`。路由器工作于`接入网`（待补充），链路层交换机常用于`网络核心`（待补充）。

端系统通过`因特网服务提供商(Internet Service Provider, ISP)`接入因特网。（ISP包括住宅区ISP、公司ISP、智能手机和其他设备提供移动接入的蜂窝数据ISP等）。每个ISP自身就是一个由多台分组交换机和多段通信链路组成的网络。各ISP为端系统提供了不同的接入方式，如：住宅宽带接入、高速局域网和移动无线接入等。

#### 1.1.2 服务描述

从因特网为应用程序提供服务的基础设施出发：

因特网还包括移动智能手机和平板电脑应用程序，如：即时通讯、来自云的音乐、电影、多人游戏等。这些应用程序涉及到多个相互交换数据的端系统，即`分布式应用程序（distributed application）`。

要实现不同端系统上应用程序的交互，**起始端系统的应用程序**需要通过`套接字接口（socket interface）`请求**因特网基础设施**向**目的端系统上的应用程序**交付数据。该接口是一套发送程序必须遵循的规则集合，因特网才能将数据交付到目的地。（比如：张三洗完信后如果直接扔出窗外，则无法达到李四那里。需要写上李四的邮政编码，联系方式，姓名等，再交给邮政公司，由邮政对其信息识别成功后，转交给李四）

#### 1.1.3 网络协议

协议定义了两个或多个通信实体之间交换的`报文格式`和`次序`，以及在报文传输/接收其他事件方面所采取的`动作`

#### 1.2 网络结构

互联网按组成类型由`网络边缘`、`网络核心`和`接入网`组成。

### 1.2.1 网络边缘

由端系统（主机）构成，主机又分为客户端(client)和服务器(server)。存储应用程序。

### 1.2.2 接入网

有线或无线的通信链路，用于将端系统连接到网络核心。实际上，它是将端系统物理连接到`边缘路由器`（端系统到任何其他远程端系统路径上的第一台路由器）。

宽带住宅接入有两种最流行的类型数字户(Digital Subscriber Line,DSL)和电缆。

* DSL:住户通过电话线接入本地电话公司处获得DSL因特网接入，位于电话公司的本地中心局交换数据。

![DSL图](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/internet/dsl.png)

* 电缆接入：利用有线电视公司有线电视基础设施接入网络

* 光纤到户：最简单的光纤分布网络为，从本地中心局到每户设置一根光纤。更为一般的是 从中心局岀来的每根光纤实际上由许多家庭共享，直到对接近这些家庭 位置，才为每户分成一个独享光纤。

除了以上接入方式外，还有以太网和wifi的形式接入。

### 1.2.3 网络核心

互连的路由器，用于数据交换。

通过网络链路和交换机移动数据有两种基本方法：`电路交换(circuit switching)`和`分组交换(packet switching)`。

* **电路交换**：在发送方发送信息前，该网络必须在发送方和接受方之间建立一条连接。其建立连接的时候，预留了端系统之间沿路通信所需要的资源，也就是预留了其带宽，这使得让发送方能够以恒定速率向接收方发送数据。（如：电话网络）

* **分组交换**：端系统发送数据前，将数据拆分为一个个小的数据块，即：分组。其通常通过`存储转发传输`方式传输数据，即在数据的传输中，经过每个交换节点时，需要将其分组的所有比特都接收完后，才能往通信链路继续传输。

* **电路交换和分组交换的区别**：

**电路交换：**

1.按照`频分复用`、`时分复用`和`波分复用`的区别，将链路划分为一个个频段、时隙和波段，用户仅仅享用其中一段。不享用整个链路的资源。

2.通信前，需要先建立连接

3.独享链路的一段资源，传输稳定，速率恒定

**分组交换：**

1.传输前，将资源先分解成多个分组。传输方式分为虚电路和数据报。数据报方式传输每个分组时，每个分组需保留目标主机的完整路径，路由器不维护主机之间的通信状态。采用虚电路方式，在通信前需要在各个交换节点和目标主机间需建立虚电路，并维护之间的通信状态。

2.经过交换节点前，需要将整个分组接收完后，才能在通信链路上继续传输

3.享用整个链路的资源，但与其他用户共享，速率不稳定

### 1.3 ISP（Internet Service Provider）

`ISP`提供了将端系统接入到因特网的能力。今天的因特网实际是一个**网络的网络**。其由十多个第一层ISP和数十万个较低层的ISP组成。

其中如果位于相同等级结构层次的`ISP`能够实现对等(peer)，则其可以直接将他们的网络连接到一起，无需通过上层的`中间ISP`转发。这种模式通过`因特网交换点(Internet Exchange Point, IXP)`实现，`IXP`是一个汇合点，多个`ISP`在这里一起对等。

`ICP(Internet Content Provider)`如谷歌等，它们提供了端系统上的应用程序。其也可以通过建立`数据中心（Data Center）`和专线网络的方式，来绕过部分`ISP`。通过专线网络，让上层`ISP`和最底层的`接入ISP`直接互联。

![ISP](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/internet/isp.png)

### 1.4 分组延时、丢失和吞吐量

#### 时延的类型

* 处理时延：检查分组首部和决定该分组导向（提取分组中的ip地址，查路由表决定下一个导向），检查分组中比特级别的差错；

* 排队时延：分组在链路上等待传输的时间，其会随着流量强度的增大而变长。当流量强度大于1时，表明其比特到达对队列的时间大于从队列传出的时间，排队时延趋于无穷大。如下图：

![ISP](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/internet/queue-time.png)

(L：分组中比特数，a：分组叨叨队列的平均时间，R：传输速率。流量强度 = La / R)

* 传输时延：将所有分组的比特推向链路所需要的时间

* 传播时延：一个比特从链路起点到下一个路由器所需要的时间

![transfer](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/internet/transfer.png)

#### 丢包
一条链路中排队容量是有限的，当到达的分组发现其是一个满的队列时，由于没有地方存储这个分组，路由器将丢弃这些分组

#### 吞吐量
在源端和目标端的传输速率（数据量/单位时间）。

* 瞬时吞吐量：在一个时间点的速率

* 平均吞吐量：在一个长时间内的平均值

#### 1.5 协议层次及服务模型

因特网是一个极为复杂的系统，设计者通过分层的方式，阻止协议以及实现这些协议的网络硬件和软件。

##### 协议栈（TCP/IP协议）

各层的所有协议被称为`协议栈(protocol stack)`。因特网的协议栈由5个层次组成：物理层、链路层、网络层、运输层和应用层。如下图：

![iso-level](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/internet/transfer.png)

* 应用层：一个端系统的应用程序使用协议与另一个端系统中的应用程序交换信息分组，交换应用报文。协议包括：FTP、HTTP、DNS等。该层的分组称为`报文(message)

* 传输层：在应用程序端点之间传送应用层报文，相比于网络层，提供更可靠的服务。解决**进程到进程之间的区分**。有两种传输协议：面向连接的服务（如：TCP）和无链接的服务（如：UDP）。该层的TCP协议中的分组称为`报文段(segment)`，UDP无连接的称为`UDP数据报`.

* 网络层：获取传输层递交过来的报文段和目的地址，将网络层的分组从一台主机移动到另一台主机，解决**端到端的数据传输**。因特网的网络层包括网际协议**IP**，该协议定义了在数据报中的各个字段以及端系统和路由器如何作用于这些字段。该层的分组称为`数据报(datagram)`

* 链路层：将分组从一个节点（主机或路由器）移动到路径上的下一个节点，解决**相邻两点的数据传输**。协议包括：WIFI、WLAN、PPP等，其和物理层协议一致。该层的分组称为`帧(frame)`。

* 物理层：将链路层中的帧中的一个个比特从一个节点移动到下一个节点。

封装和解封装：
![level-relation](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/internet/level-relation.png)

##### OSI 参考模型

* 应用层：...

* 表示层：允许应用解释传输的数据。如：加密、压缩等

* 会话层：数据交换的同步，检查点，恢复

* 传输层/网络层/链路层/物理层

## 2. 应用层

### 2.1 应用层原理

#### 2.1.1 网络应用的体系架构：客户-服务器模式（C/S架构）、对等模式（P2P）、混合体（C/S和P2P）

* 客户-服务器模式：一个总是打开的主机称为服务器，其拥有一定固定的ip地址，供客户端访问。可扩展性差，当并发达到一定量时，会出现断崖式性能下降。可以通过建立数据中心，配备大量主机来解决。

* P2P模式：客户端可以请求服务端资源，当资源被返回后，也可以作为服务端向其他客户端发送资源。它们之间是相互对等的。可扩展性强。

* 混合体：通过C/S架构将客户IP的资源目录上传到中心服务器。有客户端需要下载资源时，检查中心服务器上的各个IP，哪个客户端有资源且是开机状态，然后通过P2P模式去请求该客户端的资源。

#### 2.1.2 进程通信

在同一个端系统中进程之间通过其进程间通信机制相互通信。而在不同端系统上，需要跨越计算机网络交换报文来相互通信。

这里，我们主要研究不同端系统上的进程通信

 ##### TCP socket
多数应用程序由成对的进程组成（客户/服务器），从应用层的一个进程向另一个应用层进程发送报文必须通过下层传输层的网络。即`套接字接口（socket api）`向网络传送和接收数据。而`套接字接口`的需要 `发送方进程`、`数据内容`和`接收方进程`三个参数才能实现。

标识一个唯一进程： ip地址 + 协议类型(TCP/UDP) + 端口号

如果使用面对连接的服务（TCP），每次应用层之间的进程通信，都需要带上其`发送方进程（IP + 端口号）`、`数据内容`和`接收方进程（IP + 端口号）`三个参数。而`发送方进程（IP + 端口号）`和`接收方进程（IP + 端口号）`是固定的。实际上不需要每次都让层与层之间的传输带上该相同参数。

我们通过可以通过`TCP`的`套接字（socket）`来避免该情况，它**是四元组的一个具有本地意义的标识，代表两个进程的会话关系**。源传输层将该`TCP socket`发送到目标传输层后，通过查询`TCP socket表`解析该`套接字`，从而获得其四元组的内容，即 源应用进程 和 目标应用进程 信息。（四元组：源IP + 源端口 + 目标IP + 目标端口）。

所以，如果是面向连接的服务进程需要通信，需传`TCP socket`和数据内容即可。

##### UDP socket

`UDP socket`由本IP和本端口号组成，是一个二元组，其指定了应用所在的一个端节点。

非面相连接的服务进程通信需要提供`源UDP socket`、`目标UDP socket`和数据内容

##### 传输层提供的服务
TCP服务：

* 可靠的传输服务

* 流量控制，发送方不会淹没接收方

* 拥塞控制，当网络出现拥塞时，能抑制发送方

* 面向连接，要求在客户端进程和服务器进程之间建立连接

UDP服务：（应用在一些流媒体服务，电话等）

* 不可靠数据传输

* 不提供可靠、流量控制、拥塞控制、时间、带宽保证、建立连接等服务

### 2.2 Web 与 Http

#### 2.2.1 HTTP 概况

`HTTP`不保存关于客户的任何信息，其是一个`无状态协议`。但可以通过`cookie`等方式，让服务器能存储/识别对应的客户信息。

HTTP分为持续性连接和非持续性连接

* **持续连接**：所有的请求及其响应经相同的TCP连接发送（HTTP 1.1）

* **非持续性连接**：每个请求/相应对是经一个单独的TCP链接发送（HTTP 1.0）

### 2.3 FTP

`FTP`是一个有状态的协议，其通常用于客户端和服务端的文件传输

### 2.4 SMTP（简单邮件传输协议）

使用TCP在客户端和服务器之间传送报文，使用持久连接

直接传输，不存在中间服务器。由发送方服务器直接到接收方服务器

传输三阶段：握手、传输报文、关闭

发送方通过`代理客户端`使用`SMTP`向`发送方邮件服务器`发送邮件，再由`发送方邮件服务器`发送到`接收方服务器`。然后接收方人员通过`接收方代理服务器`向`接收方服务器`使用 `POP3`等协议进行拉取资源。

**注意**：由于`SMTP`是一个推协议，但`代理接收方`是需要拉取`接收方服务器`的邮件，所以这里不再使用`SMTP`，而是`POP3`等拉协议 。

![smtp](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/internet/smtp.png)

### 2.5 DNS

DNS协议运行在`UDP`之上 使用`53号`端口。

#### 2.5.1 DNS提供的服务

* 将域名转换为ip地址（主要功能）

* 提供`主机别名`，相较于`主机规范名`更加容易记忆。如一个`主机规范名`为`relay1.west-coast.enterprise.com`的主机可能还有一到两个别名，如：`www.enterprise.com`。应用程序可以调用`DNS`来获取`主机别名`对应的`规范主机名`及`ip地址`

* 提供`邮件服务器别名`，原理同上

* 负载均衡，一个ip地址集合与同一个规范主机名相联系

#### 2.5.2 DNS层次结构

DNS在因特网中并不是只使用一个`DNS 服务器`来完成所有ip和域名的映射。而是使用大量的DNS服务器，它们以层次方式组织，并分布在全球范围内。

大致说来 有3种类型的DNS服务器 `根DNS服务器`、`顶级域(Top Level Domain, TLD)的DNS服务器`和`权威DNS服务器`

* 根DNS服务器：是互联网域名解析系统（DNS）中最高级别的域名服务器，负责返回`顶级域`的域名服务器地址

* 顶级域DNS服务器：每个顶级域（如：com、org、net、edu和gov）和国家的顶级域（如：uk、fr、ca和jp），都有TLD服务器（或服务器集群）。提供权威DNS服务器 IP地址

* 权威DNS服务器：在因特网上具有公共可访问主机 (如Web服务器)的组织机构必须提供公共可访问的DNS记录， 这些记录将这些主机名
字映射为IP地址。而一个组织机构`权威DNS服务器`收藏了这些DNS记录。其提供了域名和`IP`地址的映射关系。

![dns1](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/internet/dns-structure.png)

#### 2.5.3 DNS工作原理

DNS解析获取ip的方式有两种：`迭代查询` 和 `递归查询`

使用`迭代查询`方式，获取`www.example.com`的ip地址：

1. 用户打开 Web 浏览器，在地址栏中输入 www.example.com，然后按 Enter 键。

2. www.example.com 的请求被路由到 本地DNS服务器，这一般由用户的互联网服务提供商 (ISP) 进行管理，例如有线 Internet 服务提供商、DSL 宽带提供商或公司网络。

3. ISP 的 `本地DNS服务器` 将 含有 www.example.com 主机名的查询报文 发送到 `根DNS服务器`。该`根DNS服务器`注意到`.com`前缀后，将 负责`.com`的`顶级域DNS服务器`的IP地址列表返回。

4. 获取到`顶级域DNS服务器`对应的IP地址列表后，ISP再次向这些`顶级域DNS服务器`之一发送查询报文。该`顶级域DNS服务器`注意到`example.com`前缀后，用`权威DNS服务器`的IP地址进行响应。

5. ISP 的 `本地DNS服务器`选择一个`权威DNS服务器`（ Amazon Route 53 名称服务器）继续发送查询报文。

6. `权威服务器`（Amazon Route 53 名称服务器）在 example.com 托管区域中查找 www.example.com 记录（注意：共同实现DNS分布式数据库的所有DNS服务器存储了资源记录-Resource Record），获得相关值，例如，Web 服务器的 IP 地址 (192.0.2.44)，并将 IP 地址返回至 `本地DNS服务器`。

7. ISP 的 `本地DNS服务器`最终获得用户需要的 IP 地址。`本地DNS服务器`将此值返回至 Web 浏览器。`本地DNS服务器`还会将 域名映射的 IP 地址**缓存 (存储)**（缓存时长由用户设置），以便它能够在下次有人浏览 example.com 时更快地作出响应。

8. Web 浏览器 向 www.example.com 对应的 IP 地址的服务发起资源请求。这是您的内容所处位置，例如，在 Amazon EC2 实例中或配置为网站端点的 Amazon S3 存储桶中运行的 Web 服务器。

9. 192.0.2.44 上的 Web 服务器或其他资源将 www.example.com 的 Web 页面返回到 Web 浏览器，且 Web 浏览器会显示该页面。

![域名解析-迭代](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/internet/dns-analyze.png)

`迭代查询`获取某域名的ip地址：

![域名解析-递归](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/internet/dns-analyze2.png)

### 2.6 P2P架构

P2P(Peer to Peer)某主机既可以作为客户端请求资源也可以作为服务端返回资源。

特点：性能高，可扩展性强，但不稳定

P2P架构分为`结构化`和`非结构化`

#### 2.6.1 结构化P2P

节点id按照大小组成一个有序的环形结构，对应资源的id值和节点id值在一个空间内。当需要请求某资源时，根据其内容id快速定位到拥有该资源的节点id（IP地址），然后分发资源。
#### 2.6.2 非结构化P2P:

**集中性目录**

主机A向中心服务器请求某资源，中心服务器会在内部进行检索，查找含有该资源且是开启状态的其他主机。如果主机B拥有该资源，且是开启状态，中心服务器向主机A返回主机B的地址。这样，主机A就可以去请求主机B上的资源了。资源获取后，主机A上报给中心服务器，表明其也拥有了该资源，中心服务器将其信息进行保存。

**完全分布式**

主机A向周围的主机发送请求，查看是否有需要的资源。如果没有，主机A周围的主机向自身周围的主机发起查询请求，直到找到含有该资源的某主机，反向返回资源。

**混合体**

上述两种结合

### 2.7 视频流和CDN

视频的一个重要特征是它能够被压缩，因而可用比特率来权衡视频质量，比特率越高，图像质量越好。

#### 2.7.1 HTTP流 和 DASH

在http流中，视频作为一个普通文件存储在服务器中，每个文件有一个特定的url。当用户需要看这个视频时，客户和服务器建立一个tcp连接并通过get请求获取该文件资源。客户端收到资源后进行缓存，当缓存超过一定预设的上限时，便开始播放视频。同时，客户端继续请求视频文件资源，缓存该视频后面的帧。

http流 方式存在一个严重缺陷是：不管客户的带宽如何，都是收到相同编码的视频。

而在`DASH(Dynamic Adaptive Streaming over HTTP)`中，视频被编码为几个不同比特率的版本，当可用带宽较高时，用户自动选择高质量的视频；可用带宽较低时，选择较低比特率（低质量）的版本。

使用`DASH`后，每个视频版本存储在服务器中，同时存在一个`告示文件（manifest file）`，为每个版本提供一个url和比特率。用户请求视频资源之前，先请求该`告示文件`，该文件标记了视频各种各样的版本，同时视频被分为一块一块的结构（如：8-10秒为一块），每块结构对应的url也可以从告示文件获取。客户进行选择某版本的一块进行下载，在下载该块的同时，也测量带宽并运行一个`速率决定算法`来决定下次请求的块是高质量的还是低质量的。

#### 2.7.2 CDN

`CDN（Content distribution network）`，全网提前部署缓存节点，存储服务内容，就近为客户提供服务，提高用户体验

**CDN的工作原理**

1. 用户访问www.NetChinema.com

2. 用户主机发送 www.NetChinema.com 的DNS请求到`本地DNS服务器`

3. 本地服务器发送查询报文到到`权威DNS服务器`中，该服务器收到查询报文后，并不返回对应的IP地址，而是返回一个`CDN域名`

4. 本地服务器继续发送查询报文到第三步返回的`CDN域名服务器`，然后该`CDN域名服务器`返回其内容服务器的IP地址

5. 本地服务器将`IP`地址返回到用户主机

6. 用户主机收到对应CDN内容服务器的IP地址，它与具有该IP地址的服务器创建了一条直接的TCP连接，并对资源发出请求。

![CDN工作原理](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/internet/cdn.png)

## 3. 传输层

### 3.1 概述和传输层服务

#### 3.1.1 目的
为运行在不同主机上的**应用进程**提供逻辑通信功能。（逻辑通信：看起来两个主机像是直接连在一起的，实际上，它们可能在世界的两端，需要经过多层网络和不同类型链路的传输才能到达）

#### 3.1.2 工作流程

在发送端，传输层从应用层某应用进程接收到`应用报文`，然后将应用报文分为较小的块，并为每块加上一个传输层首部，用来生成`报文段`，然后将`报文段`传递给发送端的网络层；

中间通过网络中的路由器转发和链路传输；

在接收端，网络层从`数据报`中提取传输层`报文段`，并将其上交给传输层，传输层再处理接收到的`报文段`，在上交给接收端应用进程使用；

### 3.2 多路复用与多路分解

#### 3.2.1 基本概念

多路复用：从多个套接字socket接收来自多个应用进程的报文，根据套接字的对应的IP地址和端口号等信息对报文段头部加以封装

多路分解：根据报文段头部信息中的IP地址和端口号将接收到的报文段发给正确的套接字（从而交给对应的应用进程）

**注意：**

针对TCP，其是面向连接的，其`TCP socket`由源IP，源端口，目标IP和目标端口组成。发送端应用层交给传输层的内容包括`TCP socket`和`发送内容`。

针对UDP，其是无连接的。`UDP socket`由源IP，源端口组成。发送端应用层交给传输层的内容包括`UDP socket` 、`发送内容`、`目标IP`和 `目标端口`。

#### 3.2.2 TCP 多路复用/分解 流程

1. 发送端应用层将`TCP socket`和`发送内容`传递到传输层

2. 发送端传输层将socket里面的`源端口字段`和`目标端口字段`封装在头部信息中，body为`发送内容`，封装成`报文段`。向下传递给网络层`源IP`、`目标IP`和`封装好的报文段`

3. 发送端网络层通过`IP`协议将`源IP`和`目标IP`封装到头部，报文段作为body。生成数据报，尽可能的传输到目标端的网络层。

4. ...中间网络


5. 到了接收端网络层，`IP`协议将数据报的`body内容`、`源IP`和`目标IP`上交到`传输层`

6. 接收端传输层获取到下层传来的`body内容`、`源IP`和`目标IP`，并解析`body内容`获得`源端口`、`目标端口`和`发送内容`，通过`源IP`、`目标IP`、`源端口`和`目标端口`便能找到对应的`TCP socket`，然后将`TCP socket`和`发送内容`上交到接收端应用层

7. 接收端应用层根据下层上交的`TCP socket`确定两个主机的关系，找到对应通信的`pid 应用进程`。再将`发送内容`传递给应用进程

#### 3.2.3 UDP 多路复用/分解 流程

1. 发送端应用层将`UDP socket`、`目标IP`、`目标端口`和`发送内容`传递到传输层

2. 发送端传输层将`源端口`、`目标端口`和`发送内容`封装成`UDP数据报`，然后向下层传递`源IP`、`目标IP`和`UDP数据报`

3. 发送端网络层将其分装成`IP分组`

4. ...中间网络


5. 到了接收端网络层，解析`IP分组`，向上面的传输层传递`源IP`、`目标IP`和`UDP数据报`

6. 接收端传输层获取到下层传来的`源IP`、`目标IP`和`UDP数据报`，并解析数据报从而获取对应的`目标端口`。再通过`目标端口`和`目标IP`获取到`UDP socket`。最后向上层提供`UDP socket`和`发送内容`

7. 接收端应用层根据下层上交的`UDP socket`找到对应的应用进程，通过获取`发送内容`传递数据

### 3.3 无连接传输：UDP

UDP(User Datagram Protocol)传输的内容可能会丢失、乱序、无拥塞控制（传输速率等不被限制）。其无需握手，每个UDP报文段单独处理。常被用于流媒体、DNS

#### 3.3.1 UDP报文段结构

**UDP报文结构组成**

* 数据字段：应用层提供的数据（“发送内容”）

* UDP首部：由`源端口号`、`目的端口号`、`长度`和`检验和`四个字段组成

![UDP结构](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/internet/udp-structure.png)

长度字段指示了在UDP报文段中的字节数（首部加数据）

`检验和`提供了**差错检测**的作用，用于确定当UDP报文段从源端到目标端时，其中的比特是否发生了改变。

UDP虽然提供了`差错检测`的机制，但对`差错恢复`无能为力

### 3.4 可靠数据传输原理(rdt, reliable data transfer protocol)

#### 3.4.1 停止等待可靠传输协议

版本历史：

* **rdt1.0**：经完全可靠的信道传输，只做报文的封装工作，没有任何校验机制

* **rdt2.0**：添加差错检测、接收方反馈（肯定确认(ACK, positive acknowledgement)和否定确认(NAK, negative acknowledgement)）和重传

`发送方`将`分组pkt`发送到`接收方`

`接收方`先进行`差错检测`

如果`分组`有错误则发送`NAK`到`发送方`，`发送方`收到`NAK`后重复发送该`分组`；

如果`分组`正确，则发送`ACK`到`发送方`，发送方收到`ACK`后继续发送下一个`分组`

* **rdt2.1**：对`ACK`分组进行差错检测

如果接收方收到的`ACK`分组检测有错误，则直接重新发送上一个`分组`。接收方在收到其`分组`后，检测`分组编号`是否重复，如果重复，则丢弃`分组`。

* **rdt2.2**：丢弃`NAK`分组，使用不同`ACK`编号回答来表示。如下：

`发送方`发送`P0分组`到`接收方`

`发送方`接收后发送`ACK0`到`发送方`

`发送方`继续发送`P1分组`到`接收方`

`接收方`检测到`P1分组`出错，则发送`ACK0`到发送方。（表明上一个分组是正确的，而不对目前的分组直接判定）

`接收方`收到`ACK0`后，不是自己`P1`需要的的`ACK1 确认分组`，则继续发送`P1分组` 

* **rdt3.0**：具有比特差错和分组丢失的信道

rdt3.0增加了`超时重发`的机制，`发送方`在发送`分组`后，开始计时，如果收到对应`ACK分组`的时间大于了超时时间。超时后，立刻重发该`分组`。避免了`接收方`和`发送方`同时等待，导致死锁

![rdt3-1](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/internet/rdt3-1.png)
![rdt3-2](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/internet/rdt3-2.png)

#### 3.4.2 流水线可靠传输协议

在3.4.1中，rdt3.0解决了分组丢失、分组出错等问题。但每次发送方发送一个分组就开始等待`确认分组（ACK）`，收到`确认分组`后才发送下一个分组，整个信道中做多存在一个分组，利用率很低。

`流水线可靠传输协议`用于解决上述问题，通过足够长度的分组编号，发送不断发送分组，不用等待`确认分组`回来在发送下一个分组。

解决流水线的差错恢复有两种基本方法是：`回退N步`和`选择重传`

##### 3.4.2.1 前置概念

发送缓冲区：在内存中的一个区域，其用于将 "已发送但还没得到确认的分组" 快速重发。

发送窗口：已发送但还没得到确认的分组，最大即发送缓冲区的范围

接收窗口（接收缓冲区）：容纳可以被接收的分组，即分组序号在接收窗口内的分组。如：分组10发送到了接收方，此时的接收缓存区容纳的范围是4-6，分组10将被抛弃，分组4-6被接收。

![gbn](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/internet/gbn.png)

##### 3.4.2.2 回退N步(Go-Back-N)

发送方一次可以发送多个分组，但接收方的`窗口长度`为1，只能**按序接收**。

正常：发送方发送了分组1，2，3，4，如果接收方都成功接收了，接收方会返回一个`ACK=4`（已发送的最大分组编号）发送到接收方。告诉接收方其分组1，2，3，4都被接收了，后续从分组5开始发送。

超时：发送方发送了分组1，2，3，4，而只收到了分组1的确认，分组2超时了。那么其发送方需要回到分组2，将分组2，3，4三个分组重新发送。（只维护一个计时器）

运行流程如下图（红色：发送缓冲区，绿色：已确认分组，白色：待发送分组）：

![gbn-process](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/internet/gbn-process.png)

##### 3.4.2.3 选择重传(Selective Repeat, SR)

发送方一次可以发送多个分组，接收方的`窗口长度`大于1，可以**乱序接收**。

正常流程：发送方发送了分组1，2，3，4，如果接收方都成功接收了，其每个分组都会收到一个`ACK`

超时：发送方发送了分组1，2，3，4，而只收到了分组1，3，4的确认，分组2超时了。那么发送方只需将分组2重传即可。（每个分组都单独维护一个计时器，某分组超时，单独重发该分组）

![sr-process](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/internet/sr-process.png)

## 3.5 面向连接的的传输：TCP

### 3.5.1 概念、特点

* 点对点：单个发送方与单个接收方之间的连接

* 可靠的、按顺序的字节流传输

* 发送和接收缓存

* 全双工通信：在同一连接中数据双向流动。

* 面向连接：在数据交换前需要握手，建立连接

* 流量控制：发送方不会“淹没”接收方

### 3.5.2 报文段结构

>发送方与接收方协商最大报文长度(MSS)。将应用层传递下来的报文按`MSS`进行切割，形成一个个tcp传输的报文段。

32比特的`序号字段(sequence window field)`：报文段载荷的

32比特的`确认号字段(acknowledgement number field)`

16比特的`接收窗口字段(receive window field)`：用于流量控制，指示愿意接收的字节数量

4比特的`首部长度字段(header length field)`

`选项字段`：用于发送方与接收方协商最大报文长度(MSS)时作为协调因子使用

6比特的`标志字段`：ACK => 确认字段，SYN => 表明请求连接，FIN => 拆除链接，RST => 复位，用来异常的关闭连接

![tcp-structure](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/internet/tcp-structure.png)


### 3.5.3 可靠传输协议：快速重传

快速重传：在收到3次冗余的ACK后，立即重传丢失的报文段（在定时器过期之前）

![quick-send](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/internet/quick-send.png)

### 3.5.4 流量控制

TCP让发送方维护一个`接收窗口`来提供流量控制。其表明了接收方还有多少可用的`缓存空间`，从而让发送方控制发送速度（流量控制）。

由于TCP是`全双工通信`（应用数据从进程A流到进程B，进程B也流转数据到进程A），在连接端的发送方都各自维护一个接收窗口

### 3.5.5 TCP 连接管理
#### 3.5.5.1  三次握手

client_isn: 客户端的初始序号

server_isn: 服务端的初始序号

SYN: 建立连接请求的报文段

![tcp-connect](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/internet/tcp-connect.png)

#### 3.5.5.2 四次挥手

客户端发起一个关闭连接命令：客户TCP向服务器进程发送一个特殊的TCP报文段，其首部的一个标注位即`FIN比特`被设置为1

服务器收到该报文段后，向客户端发送确认报文段

反之同理

![tcp-disconnect](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/internet/tcp-disconnect.png)

## 3.6 TCP 拥塞控制

### 3.6.1 如何检测拥塞

1. 报文段传输超时

2. 3次冗余ACK确认

### 3.6.2 拥塞控制方法

当TCP建立连接后，通常`拥塞窗口 (congestion window, cwnd)`初始设置为一个`MSS`，但一般来说，其使用的带宽达不到期望的值。于是，开始执行下面的`TCP拥塞控制算法`，达到最理想的传输速率时，同时尽可能的避免拥塞

1. 慢启动：将拥塞窗口设置为1个MSS，然后成指数增加`MSS`(1 => 2 => 4 => 8)。

如果遇到了**报文段超时**，则将当前的`拥塞窗口`的一半保存并记录为`ssthresh`（慢启动阀值），并重新进行慢启动；当第二次慢启动`拥塞窗口`达到`慢启动阀值`后，则进入**拥塞避免阶段**

如果遇到**3次冗余ACK确认**，则直接转入**快速恢复阶段**

2. 拥塞避免：当`拥塞窗口`达到`慢启动阀值`后，`TCP`将保守的增加`拥塞窗口`的值，即：每次增加一个`MSS`，而不是指数性增加

3. 快速恢复：当遇到**3次冗余ACK确认**，`拥塞窗口`将当前的`拥塞窗口`的一半保存并记录为`ssthresh`（慢启动阀值），并直接进入**拥塞避免阶段**，无需慢启动

![tcp-congestion](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/internet/tcp-congestion.png)

### 3.6.3 公平性

多台主机共享一条链路，其分得的链路带宽是1/n，即等额的。则认为该拥塞控制机制是公平的。

# 4. 网络层：数据平面

## 4.1 网络层概述

### 4.1.1 转发和路由选择（传统方法）

* 转发：当一个分组到达某路由器的一条输入链路时，该路由器需将该分组移动到合适的输出链路 - 数据平面

* 路由选择：使用`路由选择算法`来决定分组从发送主机到目标主机的路径 - 控制平面

一般来说，当某个分组到达某路由器后，会根据其路由表决定接下来转发的输出端口。而路由表由`路由选择`得出。

在传统方法中，一个路由器中集成了`转发-数据平面`和`路由选择-控制平面`，它们紧紧的耦合在了一起，当路由出现问题时，十分难以修改。

### 4.1.2 SDN（新方法）

控制平面路由选择功能和物理的路由器分离，路由选择设备仅执行转发，而远程控制器计算并分发转发表。即软件定义网络（Software-Defined Networking, SDN）

在`SDN`方法中，一旦路由转发出现了问题，通过软件修改远程控制器的转发表即可。

### 4.2 路由器组成

一台路由器由4个组件构成，输入端口、交换结构、输出端口和路由选择处理器

![route-structure](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/internet/route-structure.png)

* 输入端口：在交换结构的速率小于输入端口的汇聚速率时，在输入端口可能需要排队。（排队延迟可能导致缓存溢出，某些分组被丢掉）

* 交换结构：交换结构将路由器的输入端口连接到它的输岀端口

* 输出端口：输出端口 存储 从交换结构接收的分组

* 路由选择处理器：执行控制平面的功能。在传统路由器上，维护路由选择表与关联链路状态信息，并为该路由器计算转发表。在SDN路由器中，负责与远程控制器通信

### 4.2.3 输出端口 分组调度

先进先出、优先权排队、循环和加权公平排队

## 4.3 IP协议

### 4.3.1 IP 数据报格式

![ip-datagram](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/internet/ip-datagram.png)

### 4.3.2 IPv4 数据报分片

一个链路层能承载的最大数据量叫做**最大传送单元（Maximum Transmission Unit, MTU）**

每个数据报被封装在链路层`帧`中从一个路由器传输到另一个路由器，而从发送方到目的地所经过的链路可能使用不同的链路层协议，其`MTU`也不相同。

例如：以太网`帧`能够承受1500字节的数据报，而某些广域网链路则不超过576字节

为保证分片到目标主机后，能够组装成正确的数据报。每个分片都应该包含`头部`和`载荷部分`，其每个分片都有`偏移字段 offset`来表明其顺序是第几个分片，是否完整

### 4.3.3 IPv4 编址

每个IP地址长度为 32 比特（等价于4字节），因此总共有 2的32次幂 个（大于40亿）可能的IP地址，这些地址通常按照`点分十进制记法`书写，即地址中的每个字节用它的十进制形式书写，各字节间以句点隔开。如：192.32.216.9

#### 4.3.3.1 子网

![subnet](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/internet/subnet.png)

上述图片中，3互联主机接口与1个路由器接口的网络形成一个`子网（subnet）`

**子网的特征**

1. 一个字网内的节点（主机或路由器）IP地址的高位部分相同

2. 主机之间通过交换机可直接到达，无需经过路由器

#### 4.3.3.2 IP 地址配置

主机地址可以通过手动配置 IP地址、子网掩码、local name server(本地域名解析服务器)和default gateway（默认出口），这十分麻烦

大多数时候我们使用的是`动态主机配置协议（Dynamic Host Configuration, DHCP）`，其可以将主机连接进一个网络的自动能力。DHCP允许主机自动获取（被分配）一个IP地址。网络管理员能够配置DHCP，以对应主机与网络连接时能获取一个相同的IP地址。

#### 4.3.4 网络地址转换

本地网络只有一个有效的IP地址，那么如何通过区分本地网络不同设备发送和接收数据呢？就需要用到`网络地址转换（Network Address Translation, NAT）`，

举一个从本地网络请求外部web服务器的例子，步骤如下：

1. 当内网的某主机（IP为10.0.0.1）需要访问外网的一个web服务器（128.119.40.186:80）时，主机先为其指派了一个任意端口（如：3345），并将数据报发送到LAN中

2. NAT路由器收到数据报，并为该数据报生成一个新的端口5001（这个端口5001实际映射了内网的对应发送数据的主机10.0.0.1和端口3345，其映射关系会被保存在NAT路由器转换表中）

3. 然后将源IP替换为广域网一侧接口的IP地址，138.76.29.7。所以实际从内网出去后，再经过NAT路由器，其发送端服务变为了 138.76.29.7:5001

4. web服务器接收到请求数据，并将数据返回到NAT路由器的IP和指定端口上（138.76.29.7:5001）

5. NAT路由器根据端口5001查询转换表中的映射关系，找到对应的内网主机IP和端口，然后转发数据

**内网穿透**

当外网需要主动访问内网的某个web服务时，由于其NAT路由器的转换表中还没有对应的映射关系。所以无法知道外网过来的数据应该发送到内网的哪个主机和端口。

为了解决上述问题，我们需要用到`内网穿透`。其核心就是当外网访问NAT路由器的IP和端口时，添加转换表关系，映射到内网的指定IP和端口去。

#### 4.3.5 IPv6 


**IPv6 结构**
每个IP地址长度为 128 比特

结构如下：
![IPv6](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/internet/ipv6-structure.png)

**IPv4遗弃的结构**

在IPv6中取消了`分片/重新组装`，当遇到大的分组传输时，将拒绝接收并返回类似‘分组过大’的信息到源主机，由源主机自行处理

取消`首部检验和`，由于IPv4的首部都有一个TTL字段，没过一次路由器减一，所以每台路由器都需要重新计算其`首部检验和`，确保数据是否完整。在路由转发时候，其相当耗时，将其在这一层舍弃

IPv4的`选项`字段不再是标准必须的，其也可以由IPV6的`下一个首部`指处

IPv4 升级到 IPv6，通过`建隧道`。两个IPv6的服务需要相互通信，中间可以通过IPv4协议来进行传输，其IPv4传输的载荷其实是一个完整的IPv6结构。到了另一个IPv6协议的服务时，再进行解封装。

#### 4.4 通用转发和SDN

**通用转发**

每台分组交换机包含一张匹配加动作表，该表是由远程控制器计算和分发的

**SDN的功能**

网络设备数据平面和控制平面分离

数据平面-分组交换机：将路由器、交换机和大多数的网络设备的网络功能抽离成：按照流表（由控制平面设置的控制逻辑）进行 PDU(帧、分组)的动作（包括：转发、丢弃、拷贝、泛洪、阻塞）

控制平面-控制器+网络应用：计算和下发控制逻辑，生成流表

# 5. 网络层：控制平面

## 5.1 概述

## 5.2 路由选择算法

**目的**

从发送主机到接收主机的过程中确定一条通过路由器网络的“较好”（低开销、最小拥塞、最快）路径

**什么是路由？**

按照某种指标（传输延迟，经过的站点数目等）找到一条从源节点到目标节点的一条“较好”路径

**路由算法分类**

* 集中式路由选择算法：在执行算法前，需要获取所有节点之间的连通性及所有链路的开销，从而在执行算法时获取一条最优路径。具有全局状态信息的算法常被称作**链路状态（Link State, LS）算法**

* 分散式路由选择算法：路由器仅获得相邻节点的信息交换就开始执行算法，计算出下一次跳转的节点位置，然后基于新的节点再通过获取其相邻节点信息以迭代、分布式方式进行计算，常被称作**距离向量（Distance-Vector, DV）算法**。

### 5.2.1 链路状态（Link State, LS）路由选择算法

**实现步骤**

1. 测量相邻节点的“路径开销”

2. 每个节点向网络中所有其他节点广播链路状态分组

3. Dijkstra 算法获取源节点到其他所有节点的最短路径

**Dijkstra 算法**

核心思想：贪心算法

前置概念：

* v节点：其由二元组（D(v), p(v)）标记，D(v)表示源节点到本节点的开销，p(v)表示延着最低开销路径的上一个节点-v的邻居）

* N'：当前已知最优路径的节点集合（永久节点的集合）

* N：非永久节点 {1 - N'}，即临时节点集合

步骤：

1. 在初始化步骤中，首先将所有节点放入到`集合N`中。（源节点用`(0, null)`表明“`源节点`到当前节点的开销为0，到延着最短路径的上一个节点为空”，其余节点用`x(∞, undefined)`表明源节点到当前节点的开销无穷大，上个节点未知）

2. 将`源节点`作为`基准节点`（例：节点a），分别计算`源节点`到`基准节点`的`相邻节点`的路径开销（举例：到节点b的开销是3，到节点c的开销是4）

3. 将步骤2计算得到的开销 与 原来的节点开销 比较大小，如果新计算的结果小于原来的节点开销，则用新计算的结果替换原来的值（如节点d是d(5, c)，新计算从f节点路径得到的开销是4，则将节点d修改为d(4, f)）

4. 比较`临时节点集合 N`中的所有值（开销）大小，将值最小的放入到`永久节点集合 N'`中

5. 将步骤4获取的路径开销最小的节点作为基准节点，重复步骤2-步骤4，直到`临时节点集合 N`为空

![dijkstra](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/internet/dijkstra.png)

时间复杂度：O(n<sup>2</sup>)

`Dijkstra` Javascript实现：https://github.com/kerwin-ly/javascript-algorithms/tree/master/src/algorithms/graph/dijkstra

### 5.2.2 距离向量（Distance-Vector, DV）路由选择算法

**实现步骤**

每个路由器维护一张表，该表存储 目标节点、该节点经过的下一个节点、该节点经过下一个节点到目标节点的开销
|  To(目标节点)   | Next(下个相邻节点)  | Cost（开销）  |
|  ----  | ----  | ----  |
| 节点Z  | 节点B | 23 |
| 节点Z  | 节点C | 12 |
| 节点Z  | ... | ... |

各路由器与相邻路由器交换路由表中的`距离向量`

DV算法的核心是`Bellman-Ford`方程（动态规划），如下

求节点x 到 节点y 的最小开销路径，公式如下：

**d<sub>x</sub>(y) = min<sub>v</sub>{ c(x, v) + d<sub>v</sub>(y) }**
>字段含义
d<sub>x</sub>(y)：当前节点x到目标节点y的开销
c(x, v)：当前节点x与相邻节点v的路径开销（注意v表示相邻节点的集合）
d<sub>v</sub>(y)：当前节点v到目标节点y的开销

递归执行上述方程，最终获得最小开销路径

![bellman-ford](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/internet/bellman-ford.png)

时间复杂度：O(VE) (V表示节点数量，E表示边的数据)

`Bellman-Ford` Javascript实现：https://github.com/kerwin-ly/javascript-algorithms/tree/master/src/algorithms/graph/bellman-ford

### 5.2.3 LS算法 和 DV算法 的区别

LS算法的`报文复杂性`更高，`收敛速度`较快，`健壮性`更高

## 5.3 因特网中自治系统内部的路由选择：OSPF(开发最短路优先)

**特性**

1. 安全：所有的OSPF报文都是经过认证的，防止了恶意攻击

2. 允许多条相同开销的路径

3. 支持按照不同的代码计算最短路径（如：时间、经过跳数、带宽延迟）

3. 对单播多播路由选择的综合支持

4. 支持在单个`自治系统（Autonomous System, AS）`中的层次结构：一个OSPF自治系统能够层次化配置多个区域，在执行LS算法时，可以在区域内泛洪，而不是整个网络。结构如下图：

![ospf](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/internet/ospf.png)

## 5.4 ISP之间的路由选择：BGP

如果所有网络都在一个平面上，全球上亿的网络，复杂性过高。如：执行一次链路状态算法，根据不可能及时得到结果。

所以考虑将网络“分层”，按照物理链路等因素，划分一个个`自治系统`，其`自治系统`内部可以运行自定义的路由选择算法，如：OSPF等。

通常来说，每个`自治系统`对外的网关路由器一般只有1，2个。为了各个`自治系统`能相互通信转发，所有的`自治系统`必须运行相同的`自治系统`间路有选择协议，称为**边界网关协议（Border Gateway Protocol, BGP）**

* eBGP(外部BGP): 跨域两个`自治系统`的BGP连接

* iBGP(内部BGP): 相同AS中的两台路由器之间的BGP绘画

eBGP和iBGP结构如下图所示：

![bgp-type](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/internet/bgp-type.png)

**BGP的路由选择算法**

BGP是一种改进版的`距离矢量算法`，其不仅传递到各个子网的代价，其还会携带经过的路径。防止了环路和无穷次的计算。

**BGP路由选择策略**

在`自治系统`内部的网关协议，更关注的是**性能**。而在`自治系统`之间的网关协议，更关注**策略**。（如果AS1不允许AS2的网络资源访问，则网关必须拦截其转发，这十分重要。）

## 5.5 SDN(Software defined networking) 控制平面

### 5.5.1 特征

1. 基于流的转发。传统方法中 的IP数据报的转发仅依据数据报的目的IP地址进行，而OpenFlow 1.0抽象允许11个不同的首部字段值进行转发。

2. 数据平面和控制平面分离。数据平面仅执行路由转发功能，控制平面由软件实现，计算流表再交给数据平面。

3. 网络控制功能。通过运行在控制平面的软件可以维护准确的网络状态信息，同时也可以监控其运行的网络设备

4. 可编程的网络。通过运行在控制平面的软件，可以执行服务器的负载均衡转发分组，控制防火墙等

![sdn-feature](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/internet/sdn-feature.png)

### 5.5.2 OpenFlow 协议

OpenFlow协议运行在SDN控制器 和 SDN控制的交换机或其他设备中。其运行在TCP之上，默认6653端口。

### 5.5.3 数据平面和控制平面交互的例子

![sdn-process](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/internet/sdn-process.png)

# 6. 链路层和局域网

节点：运行链路层协议的任何设备

链路：沿着通信路径连接相邻节点的通信信道

## 6.1 链路层概述

### 6.1.1 链路层提供的服务

1. 将网络层下发的数据报封装成`帧`。一个帧由一个数据字段（网络层数据报）和多个首部字段组成

2. 链路接入。媒体访问控制（Medium Access Control, MAC）协议规定了帧在链路上的传输规则，尤其是当多个节点的帧共享当个广播链路时，由其进行协调

3. 可靠交付。类似传输层协议TCP，通过“确认”和“重传”等机制，保证无差错的经链路层移动每个网络层数据报。

4. 差错检测和纠正。发送节点在`帧`中包括差错检测比特，让接收节点进行差错检查。

## 6.2 差错检测和纠正技术

奇偶校验、检验和方法和循环冗余检测

## 6.3 多路访问链路和协议

**网络链路类型**

* 点对点链路：链路的一段的单个发送方和链路另一端的单个接收方组成。广域网中常见。

* 多对多链路（广播链路）：多个发送和接收节点连接都连接到相同的、单一的、共享的广播信道上。

### 6.3.1 信道划分协议(channel partitioning protocol)

 * 时分多路复用：将时间划分为时间帧，并进一步话费每个时间帧为N个时隙（slot）

 * 频分多路复用：将R bps信道划分为不同的频段（每个频段具有R/N带宽），并把每个频率分配给N个节点中的一个

 * 码分多址：对每个节点分配一种不同的编码

### 6.3.2 随机接入协议

当多个节点在信道中传输“碰撞冲突”时，每个节点按照一定的`随机时延`重复发送，直到该帧无碰撞通过为止

**时隙ALOHA**

所有节点同步它们的传输，必须等到一个时隙开始时，才进行传输。

[!mul-transfer-time](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/internet/mul-transfer-time.png)


**ALOHA**

当`帧`被组装完毕后马上传输，不需要等到一个时隙开始。相对`时隙ALOHA`冲突的概率更大。

[!aloha](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/internet/aloha.png)

**载波侦听多路访问（CSMA）**

在发送`帧`之前，先监听信道是否有帧正在发送，如果没有，则发送。（可能存在传输延迟，也可能导致信道冲突或浪费）

**具有碰撞检测的载波侦听多路访问（CSMA/CD）**

在发送`帧`前和发送中，都监听信道中是否有其他`帧`在传输

以太网CSMA/CD 二进制指数退避算法：节点随机从{0, 1, 2, ... , 2<sub>k</sub>-1}(k代表发送帧的碰撞次数，最大为10)中取值，然后乘上 `512`（即发送512比特进入以太网所需时间量），这个时间即为节点发送帧等待的时间。如果两个节点选择的“等待时间”一致，则k+1，继续执行该算法。

举例：首次碰撞，从{0,1}选择，第2次，从{0,1,2,3}选择；第3次，从{0,1,2,3,4,5,6,7}选择...

通过该算法，可以有效平衡`信道的利用率`和`等待时间`

### 6.3.3 轮流协议

在上述的协议中，如果将信道平均划分，每个信道拥有 n/R 的带宽。(n: 信道数量，R: 链路总带宽)

在低负载的时候即使只有一个节点发送数据，但仍只能使用 n/R 的信道带宽，

可以采用`轮流协议`来处理该场景

**轮询协议**

添加一个主节点对所有发送节点进行轮询查看是否有数据需要发送（缺点：主节点挂了，则所有节点无法发送数据）

**令牌传递协议**

一个令牌的`帧`在多个发送节点中“环绕”，如果有节点需要发送`帧`，获取令牌并发送数据帧。如果没有数据需要发送，则将令牌交给下一个节点。最后一个节点交给第一个节点。（缺点：令牌如果丢失，则所有节点都在等待令牌）

## 6.4 交换局域网

### 6.4.1 链路层MAC地址和ARP

**MAC地址**

路由器或主机的适配器（网卡）具有链路层地址，即`MAC地址`（也叫`LAN地址`或`物理地址`）

ARP协议（Address Resolution Protocol, ARP）将网络层的`IP地址`（分层的）解析为`MAC地址`（平面的），用于链路层在相邻节点的传输。

网卡需要获取当前节点和目标节点的`MAC地址`在链路层进行传输，每经过一个路由器/交换机，其MAC地址更新。

### 6.4.2 以太网

以太网是第一个广泛部署的高速局域网，其几乎占领现有的有线局域网市场。

### 6.4.3 链路层交换机

**作用**

借助于`交换机表`（交换机表包含目标MAC地址、发送接口和时间），决定一个`帧`是通过哪个接口转发到目标MAC地址或者丢弃

交换机表通过本身的`自学习`能力，将目标MAC地址和自身接口进行映射，并记录时间。下一次有相同的目标MAC地址时，直接通过某接口转发。在经过一定时间后，需要删除该映射关系。重新映射，保证其一致性。

**交换机和路由器的比较**

交换机通过`MAC地址`转发分组，工作在链路层

路由器通过`IP地址`分层经过每个子网，工作在网络层

[!diff](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/internet/diff.png)

# 8. 计算机网络中的安全

## 8.1 加密原理

**对称加密**

双方需要协商确定key，加密和解密使用同一密钥（如：DES、3DES、AES）

* 优点：运算速度快

* 缺点：无法安全地将密钥传输给通信方


**非对称加密(公开密钥加密)**

1. 传输加密：公开密钥所有人都可以获得，发送方获得接收方的公钥之后，将发送数据使用公钥进行加密，然后发送给接收方，接收方收到加密后的数据后使用自己的私钥解密，获取原数据。（如：RSA算法）

* 优点：可以更安全地将公开密钥传输给通信发送方

* 缺点：运算速度慢

2. 数字认证：接收方如果通过发送方的公钥，能解密发送方经过自己私钥加密后的数据。则能唯一识别发送方。（因为私钥只有发送方才有）。下面举例git ssh等认证

1) 将客户端的公钥保存在git服务器

2) 当客户端连接到git服务器后，服务器返回一个随机字符串到客户端

3) 客户端使用自己本地的私钥对随机字符串进行加密，然后将加密后的数据发送到git服务器

4) git服务器收到加密的数据后，使用第1步预存到服务器的公钥进行解密。如果解密后的数据是第2步发送的随机字符串，则表明对方私钥正确，能唯一标识该用户。