# 从输入url到页面显示的过程

面试中，我们常常会被问到：从输入url到页面显示，中间发生了什么？

之前，我对这个问题一直是一知半解的状态，不够深入。于是，我利用闲暇时间，阅读了[《计算机网络自顶向下方法-第七版》](https://github.com/kerwin-ly/books/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E7%AC%AC%E4%B8%83%E7%89%88.pdf)的书籍，结合[中科大郑烇老师的教学视频](https://www.bilibili.com/video/BV1JV411t7ow?from=search&seid=18425226436912830366&spm_id_from=333.337.0.0)，对计算机网络的知识有了更深刻的理解，便有了这篇文章的分享。如果你想快速了解这本书相关的知识点，可以看下我之前写的[读书笔记](https://github.com/kerwin-ly/Blog/blob/master/computer-netwroking/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.md)

下面，我们进入正题，来了解 **从输入url到页面显示，中间发生了什么？**

## 1. 域名解析

域名解析是将域名转换为对应的IP的过程。

### 1.1 缓存机制

在域名解析前，首先会从浏览器缓存、系统缓存、路由器缓存、ISP缓存中递归的查找域名对应的IP地址。如果上述缓存中，均没有找到对应的IP地址，则发起域名解析请求。

### 1.2 域名的层级关系

在说域名解析前，我们需要了解DNS服务器的层级关系，其主要分为根DNS服务器、顶级域DNS服务器、权威DNS服务器。

* 根DNS服务器：是互联网域名解析系统（DNS）中最高级别的域名服务器，负责返回顶级域的域名服务器地址

* 顶级域DNS服务器：每个顶级域（如：com、org、net、edu和gov）和国家的顶级域（如：uk、fr、ca和jp），都有TLD服务器（或服务器集群）。提供权威DNS服务器 IP地址

* 权威DNS服务器：在因特网上具有公共可访问主机 (如Web服务器)的组织机构必须提供公共可访问的DNS记录， 这些记录将这些主机名
字映射为IP地址。而一个组织机构`权威DNS服务器`收藏了这些DNS记录。其提供了域名和`IP`地址的映射关系。

### 1.3 域名解析流程

下面，我们通过一个`www.example.com`的来对细节进行阐述：

1. 生成一个DNS查询报文，发送到`本地DNS服务器`，这一般由用户的互联网服务提供商 (ISP) 进行管理，例如有线 Internet 服务提供商、DSL 宽带提供商或公司网络。

2. ISP 的 `本地DNS服务器` 将 含有 www.example.com 主机名的查询报文 发送到 `根DNS服务器`。该`根DNS服务器`注意到`.com`前缀后，将 负责`.com`的`顶级域DNS服务器`的IP地址列表返回。

3. 获取到`顶级域DNS服务器`对应的IP地址列表后，ISP再次向这些`顶级域DNS服务器`之一发送查询报文。该`顶级域DNS服务器`注意到`example.com`前缀后，用`权威DNS服务器`的IP地址进行响应。

4. ISP 的`本地DNS服务器`选择一个`权威DNS服务器`（ Amazon Route 53 名称服务器）继续发送查询报文。

5. `权威服务器`（Amazon Route 53 名称服务器）在 example.com 托管区域中查找 www.example.com 记录并获得对应的IP地址，并将 IP 地址返回至 `本地DNS服务器`。

![域名解析-迭代](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/internet/dns-analyze.png)

在获取到域名对应的IP后，客户端便可以向服务器发起HTTP请求了。

## 2. 应用层 发起HTTP请求

客户端发起资源请求，进行进程之间的通信。HTTP协议是在应用层工作的，其完成了对HTTP报文等的封装。然后通过套接字接口`Socket Api`向传输层发送`数据内容`和`TCP Socket`。（Socket Api需要的参数是：发送端IP + 发送端端口 + 目标IP + 目标端口。这些参数一般封装于`TCP Socket`中，`TCP Socket`是四元组的一个具有本地意义的标识，代表两个特定进程的会话关系。所以，每次层间接口的请求，带上`TCP Socket`即可。在最后到达服务端的应用层后，其可以通过查询`TCP Socket表`解析该`套接字`，获取里面的信息）

## 3. 传输层 TCP

### 3.1 TCP 三次握手

1. 客户端**随机**生成一个客户端序列号`seq = client_isn`（isn, initial sequence number），发送该序列号和`SYN`报文（请求建立连接标识）到服务端。（第一次握手，表明客户端能正常发送，服务端能正常接收）

2. 服务端收到客户端请求后，对客户端序列号进行确认，并生成对应的`ack`确认报文，表明服务端收到了对应的请求。接着生成服务端序列号`seq = server_isn`，用于探听客户端是否能正常接收。最后将`ack`确认报文、`seq`服务端序列号和`SYN`报文一起发送给客户端（第二次握手，表明服务端能正常接收、发送，客户端能正常发送。**注意：这时候服务端还没有收到服务端序列号对应的确认字段，所以不能表明客户端能正常接收，即不能两次握手就开始发送数据**）

3. 客户端收到服务端的返回后，对客户端序列号进行确认，生成确认报文`ack`。然后生成新的客户端序列号一并发送到服务端。服务端收到后，连接建立。（第三次握手，表明了服务端和客户端都具有正常接收、发送能力）

![tcp-connect](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/internet/tcp-connect.png)

针对TCP连接，我们可以思考一下如下几个问题。

#### TCP可以两次握手就建立连接么？

不行。因为TCP是全双工通信，客户端和服务端分别扮演了“发送者”和“接收者”的角色。三次握手的目的是**保证双方都有发送和接收的能力。**

我们思考下，如果只有两次握手。当客户端发送SYN报文表明客户端有`发送能力`，报文了到了客户端后，从服务端发送ACK确认报文，表明服务端有`接收能力`。发送SYN报文，表明服务端也有`发送能力`。但仅两次握手，无法保证客户端有`接收能力`。所以有了三次握手，来确认客户端也有`接收能力`。这避免了数据传输丢包的可能，说明了其可靠性传输。

如果仅两次握手，也可能导致无效的连接，浪费资源的情况。如：客户端发送一次请求后，报文消失在了网络中。到了超时时间后，客户端又发起了一次请求，这次请求建立了双方的通信，进行数据交换后，正常关闭了连接。但过了许久，第一次发送的报文到达了服务端，服务端错误的以为客户端需要建立连接，所以返回给客户端确认报文，建立了双方连接。此时，客户端是不知情的，但服务端一直在等待客户端的数据发送。造成了资源浪费。

#### 初始序列号（ISN, Initial Sequence Number）是固定的吗？

不是。ISN随时间而变化，因此每个连接都将具有不同的ISN。ISN可以看作是一个32比特的计数器，每4ms加1 。这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。

三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。

### 3.2 封装TCP报文段
说到封装TCP报文段，我们首先得知道TCP报文段结构，如下：

>MTU：一个网络包的最大长度，以太网中一般为 1500 字节。
>MSS：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。

32比特的`序号字段(sequence window field)`：报文段载荷的

32比特的`确认号字段(acknowledgement number field)`

16比特的`接收窗口字段(receive window field)`：用于流量控制，指示愿意接收的字节数量

4比特的`首部长度字段(header length field)`

`选项字段`：用于发送方与接收方协商最大报文长度(MSS)时作为协调因子使用

数据字段

6比特的`标志字段`：ACK => 确认字段，SYN => 表明请求连接，FIN => 拆除链接，RST => 复位，用来异常的关闭连接

![tcp-structure](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/internet/tcp-body1.jpeg)

数据会被以 MSS 的长度为单位进行拆分，拆分出来的每一块数据都会被放进单独的网络包中。也就是在每个被拆分的数据加上 TCP 头信息，然后交给 网络层IP 模块来发送数据。
 
### 4. 网络层 IP

TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成网络包发送给通信对象。

首先，我们来看下 IP 报文头部的结构：

![ip-structure](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/internet/ip-body.jpeg)

在 IP 协议里面需要有源地址 IP 和 目标地址 IP：

源地址IP，即是客户端输出的 IP 地址；
目标地址，即通过 DNS 域名解析得到的 Web 服务器 IP。

当存在多个网卡时，即有多个输出的IP地址可选。这时，就需要根据路由表规则，将服务器的目标地址和源地址进行`与运算`匹配，来判断哪一个网卡作为源地址 IP。

确定完源IP地址后，开始封装IP头部，其结构如下：

![ip-structure](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/internet/ip-body2.jpeg)

TODO mac地址

## 参考链接
[键入网址到网页显示，期间发生了什么？](https://xiaolincoding.com/network/1_base/what_happen_url.html)