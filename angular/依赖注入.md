# Angular 依赖注入

该文章主要讲述内容如下：

1.为什么需要依赖注入，什么是依赖注入

2.依赖注入是如何实现的

3.依赖注入在Angular中的应用

## 一、理解依赖注入
在[Angular官网](https://angular.cn/guide/dependency-injection)中有如下一段对其的概述：

>依赖项是指某个类执行其功能所需的服务或对象。依赖项注入（DI）是一种设计模式，在这种设计模式中，类会从外部源请求依赖项而不是创建它们

下面，我将通过实际例子来对这段话进行说明

某天，你收到一个需求，在`UserService`用户服务中，需要依赖一个`AuthService`授权服务对用户的权限进行校验

代码如下：
```ts
// auth.service.ts 鉴权服务
export class AuthService {
    permissions: string[];

    constructor(permissions: string) {
        this.permissions = permissions;
    }

    check(): void { ... }
}


// user.service.ts 用户服务
export class UserService {
    private authService: AuthService;

    constructor(permissions: string) {
        this.authService = new AuthService(permissions);
    }
}

// test.ts
const user = new UserService(['查看用户']);
```

上述，是我们需求的简单实现，功能上没什么问题，你愉快的提交了代码。

第二天，需求变了，鉴权服务还需要提供一个`code`参数用来检查用户工号，于是你需要在实例化`UserService`的时候再加上一个参数，即使这个参数实际是`AuthSerivce`才需要的。

代码如下：

```ts
// auth.service.ts 鉴权服务
export class AuthService {
    permissions: string[];
    code: string;

    constructor(permissions: string; code: string) {
        this.permissions = permissions;
        this.code = code;
    }

    check(): void { ... }
}


// user.service.ts 用户服务
export class UserService {
    private authService: AuthService;

    constructor(permissions: string, code: string) {
        this.authService = new AuthService(permissions, code);
    }
}

// test.ts
const user = new UserService(['查看用户'], 'ZZ0001');

```

这里仅仅是举了一个简单的例子，实际场景中，我们的`AuthService`可能还会依赖其他的服务，那么如果按目前的代码设计，我们需要顺着服务依赖的链路，将参数逐层传递，才能够让其正常运行。

观察上述代码，我们会发现，由于`UserService`内部创建了`AuthService`实例，对其进行了依赖，所以在实例化`UserService`的时候，必须把`AuthService`里面需要的参数也一并带入，这里发生了耦合。

那么，我们如果把实例化操作放在外面，是不是就可以解决这个耦合问题了？

我们尝试修改代码如下：

```ts
// auth.service.ts 鉴权服务
export class AuthService {
    permissions: string[];
    code: string;

    constructor(permissions: string; code: string) {
        this.permissions = permissions;
        this.code = code;
    }

    check(): void { ... }
}


// user.service.ts 用户服务
export class UserService {
    private authService: AuthService;

    constructor(authService: AuthService) {
        this.authService = authService;
    }
}

// test.ts
const auth = new AuthService(['查看用户'], 'ZZ0001');
const user = new UserService(auth);
```

ok，通过修改，我们一定程度上完成了解耦。不用在其中一个服务改动的时候，还需要改动其他的服务了。

但随着系统越来越复杂，我们发现`UserService`还需要依赖几个服务，这几个服务又依赖了其他服务。难道我们每次要用某个服务的时候，都需要把他的依赖全部创建一遍么？这显然是不合理的。

最理想的结果是，在调用某个服务前，其依赖的服务就全部创建好了，尽管调用即可。

于是，**控制反转**和**依赖注入**的思想应运而生

在`维基百科`中，有这样的一段描述：

>控制反转（英语：Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。

再结合上面`Angular 依赖注入`描述和实际例子，我们对其进行简要概括 ：

>依赖项是指某个类执行其功能所需的服务或对象。依赖项注入（DI）是一种设计模式，在这种设计模式中，类会从外部源请求依赖项而不是创建它们

我们可以简单的进行一下概括：

1.什么是依赖注入？

在实际开发中，我们在执行某个类（如上述的`class UserService`）时，需要依赖其他的`依赖项`（如：`AuthService`）支撑。我们可以通过将`依赖项`注入到该类的方式来实现对`依赖项`的引用，而不是直接创建它们。这就是**依赖注入**

2.什么是控制反转？

起初，我们需要在执行某个类时，需要手动的去创建它的所有依赖项。而使用`依赖注入`的方式实现后，我们将创建依赖项的逻辑放在了`DI框架`（实现依赖注入的库）中，由`DI`框架控制其创建逻辑，而不是在业务代码中手动去控制，这就是**控制反转**。一句话来说，就是将“创建依赖项”的控制权，由业务代码，转移到了`DI框架`中。

3.为什么需要依赖注入？

一定程度上实现了松耦合，我们不需要担心执行某个类时，其依赖项的修改导致执行类也需要修改。同时，在执行类中，不会去创建关联其他依赖项，这让单元测试更加容易。




## 参考链接

[维基百科-控制反转](https://zh.wikipedia.org/wiki/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC)

[Angular Dependency Injection: Complete Guide](https://blog.angular-university.io/angular-dependency-injection/)

[Angular 中的依赖注入](https://angular.cn/guide/dependency-injection)

https://zhuanlan.zhihu.com/p/113299696

https://www.zhihu.com/question/265773703

[如何基于 TypeScript 实现控制反转](https://zhuanlan.zhihu.com/p/311184005)