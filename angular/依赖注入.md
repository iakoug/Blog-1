# Angular 依赖注入

该文章主要讲述内容如下：

* 为什么需要依赖注入，什么是依赖注入

* 依赖注入是如何实现的

* 依赖注入在Angular中的应用

## 一、理解依赖注入
在[Angular官网](https://angular.cn/guide/dependency-injection)中有如下一段对其的概述：

>依赖项是指某个类执行其功能所需的服务或对象。依赖项注入（DI）是一种设计模式，在这种设计模式中，类会从外部源请求依赖项而不是创建它们

下面，我将通过实际例子来对这段话进行说明

某天，你收到一个需求，在`UserService`用户服务中，需要依赖一个`AuthService`授权服务对用户的权限进行校验

代码如下：
```ts
// auth.service.ts 鉴权服务
export class AuthService {
    permissions: string[];

    constructor(permissions: string) {
        this.permissions = permissions;
    }

    check(): void { ... }
}


// user.service.ts 用户服务
export class UserService {
    private authService: AuthService;

    constructor(permissions: string) {
        this.authService = new AuthService(permissions);
    }
}

// test.ts
const user = new UserService(['查看用户']);
```

上述，是我们需求的简单实现，功能上没什么问题，你愉快的提交了代码。

第二天，需求变了，鉴权服务还需要提供一个`code`参数用来检查用户工号，于是你需要在实例化`UserService`的时候再加上一个参数，即使这个参数实际是`AuthSerivce`才需要的。

代码如下：

```ts
// auth.service.ts 鉴权服务
export class AuthService {
    permissions: string[];
    code: string;

    constructor(permissions: string; code: string) {
        this.permissions = permissions;
        this.code = code;
    }

    check(): void { ... }
}


// user.service.ts 用户服务
export class UserService {
    private authService: AuthService;

    constructor(permissions: string, code: string) {
        this.authService = new AuthService(permissions, code);
    }
}

// test.ts
const user = new UserService(['查看用户'], 'ZZ0001');

```

这里仅仅是举了一个简单的例子，实际场景中，我们的`AuthService`可能还会依赖其他的服务，那么如果按目前的代码设计，我们需要顺着服务依赖的链路，将参数逐层传递，才能够让其正常运行。

观察上述代码，我们会发现，由于`UserService`内部创建了`AuthService`实例，对其进行了依赖，所以在实例化`UserService`的时候，必须把`AuthService`里面需要的参数也一并带入，这里发生了耦合。

那么，我们如果把实例化操作放在外面，是不是就可以解决这个耦合问题了？

我们尝试修改代码如下：

```ts
// auth.service.ts 鉴权服务
export class AuthService {
    permissions: string[];
    code: string;

    constructor(permissions: string; code: string) {
        this.permissions = permissions;
        this.code = code;
    }

    check(): void { ... }
}


// user.service.ts 用户服务
export class UserService {
    private authService: AuthService;

    constructor(authService: AuthService) {
        this.authService = authService;
    }
}

// test.ts
const auth = new AuthService(['查看用户'], 'ZZ0001');
const user = new UserService(auth);
```

ok，通过修改，我们一定程度上完成了解耦。不用在其中一个服务改动的时候，还需要改动其他的服务了。

但随着系统越来越复杂，我们发现`UserService`还需要依赖几个服务，这几个服务又依赖了其他服务。难道我们每次要用某个服务的时候，都需要把他的依赖全部创建一遍么？这显然是不合理的。

最理想的结果是，在调用某个服务前，其依赖的服务就全部创建好了，尽管调用即可。

于是，**控制反转**和**依赖注入**的思想应运而生

在`维基百科`中，有这样的一段描述：

>控制反转（英语：Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。

再结合上面`Angular 依赖注入`描述和实际例子，我们对其进行简要概括 ：

>依赖项是指某个类执行其功能所需的服务或对象。依赖项注入（DI）是一种设计模式，在这种设计模式中，类会从外部源请求依赖项而不是创建它们

我们可以简单的进行一下概括：

1.什么是依赖注入？

在实际开发中，我们在执行某个类（如上述的`class UserService`）时，需要依赖其他的`依赖项`（如：`AuthService`）支撑。我们可以通过将`依赖项`注入到该类的方式来实现对`依赖项`的引用，而不是直接创建它们。这就是**依赖注入**

2.什么是控制反转？

起初，我们需要在执行某个类时，需要手动的去创建它的所有依赖项。而使用`依赖注入`的方式实现后，我们将创建依赖项的逻辑放在了`DI框架`（实现依赖注入的库）中，由`DI`框架控制其创建逻辑，而不是在业务代码中手动去控制，这就是**控制反转**。一句话来说，就是将“创建依赖项”的控制权，由业务代码，转移到了`DI框架`中。

3.为什么需要依赖注入？

一定程度上实现了松耦合，我们不需要担心执行某个类时，其依赖项的修改导致执行类也需要修改。同时，在执行类中，不会去创建关联其他依赖项，这让单元测试更加容易。

## 二、依赖注入的简单实现

那么，如何实现一个`依赖注入`功能呢？

大概实现思路是**在执行一个类之前，获取到这个类的依赖项，再将其实例化**。

想要获取类的依赖项，我们需要用到一个库[reflect-metadata](https://github.com/rbuckton/reflect-metadata)

>Reflect Metadata 是 ES7 的一个提案，它主要用来在声明的时候添加和读取元数据。在定义一个类时，咱们可以先通过`Reflect.defineMetadata`存储一些类型相关的数据，然后在实际调用类时，通过`Reflect.getMetadata`获取之前定义的数据。

首先安装这个库

```shell
npm i reflect-metadata --save
```

接着，我们尝试在执行`StorageService`类之前定义一个值并获取它
```ts
import 'reflect-metadata';

function Injectable() {
  return function (target: any) {
    // 定义一个key为user_info，用于唯一识别该metadata值；
    // 同时定义一个对象{name : 'kerwin'}作为metadata的值
    // target即UserService类
    Reflect.defineMetadata('user_info', { name: 'kerwin' }, target); 
    return target;
  };
}

class AuthService {
    constructor() {}
}

@Injectable()
class UserService {
  constructor(private authService: AuthService) {}
}

console.log(Reflect.getMetadata('user_info', UserService)); // 输出结果 => { name: 'kerwin' }
```

接着，我们只要把`依赖项`作为`@Injectable`装饰器的参数放进去，就可以在执行类之前获取到具体的依赖项了。代码如下：

```ts
import 'reflect-metadata';

function Injectable(constructorArgs: any[]) {
  return function (target: any) {
    Reflect.defineMetadata('dependencies', constructorArgs, target);
    return target;
  };
}

class AuthService {
    constructor() {}
}

@Injectable([AuthService])
class UserService {
  constructor(private authService: AuthService) {}
}

console.log(Reflect.getMetadata('dependencies', UserService)); // 输出结果 => [ [Function: AuthService] ]
```

到了这一步，我们就可以通过`@Injectable`装饰器和`reflect-metadata`库，获取到执行类的依赖项了

emm...但这里的获取方法仍有点麻烦，我们需要在`@Injectable`里面把所有参数都写一遍，但在`Angular`使用时，我们却不需要如此做。这是什么原因呢？

这就引出了我们接下来的一个配置项`emitDecoratorMetadata`

下面是来自官网对这个字段的一个概述
>With the introduction of Classes in TypeScript and ES6, there now exist certain scenarios that require additional features to support annotating or modifying classes and class members. Decorators provide a way to add both annotations and a meta-programming syntax for class declarations and members.

如果你想获取更多信息，可以查阅[文档](https://www.typescriptlang.org/docs/handbook/decorators.html)

接下来，在 `tsconfig.json` 里配置 `emitDecoratorMetadata` 

```json
{
  "compilerOptions": {
    ...
    "emitDecoratorMetadata": true
  }
}
```

配置完成后，我们运行代码，即可通过`Reflect.getMetadata('design:paramtypes', target)`直接获取到依赖项，无需添加装饰器的参数。如下：

```ts
import 'reflect-metadata';

function Injectable() {
  return function (target: any) {
    return target;
  };
}

class AuthService {
    constructor() {}
}

@Injectable()
class UserService {
  constructor(private authService: AuthService) {}
}

console.log(Reflect.getMetadata('design:paramtypes', UserService)); // 输出结果 => [ [Function: AuthService] ]
```

为什么呢？下面我们将`emitDecoratorMetadata`分别设置为`false`和`true`，并将`ts`编译为`js`来分析

```js
// emitDecoratorMetadata: false
"use strict";
// ... 部分代码省略
Object.defineProperty(exports, "__esModule", { value: true });
require("reflect-metadata");
function Injectable() {
    return function (target) {
        return target;
    };
}
...
var UserService = /** @class */ (function () {
    function UserService(authService) {
        this.authService = authService;
    }
    UserService = __decorate([
        Injectable()
    ], UserService);
    return UserService;
}());
console.log(Reflect.getMetadata('design:paramtypes', UserService)); // 输出结果 => [ [Function: AuthService] ]



// emitDecoratorMetadata: true
"use strict";
// ...部分代码省略
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v); // 获取到k,v参数并定义元数据
};
Object.defineProperty(exports, "__esModule", { value: true });
require("reflect-metadata");
function Injectable() {
    return function (target) {
        return target;
    };
}

var UserService = /** @class */ (function () {
    function UserService(authService) {
        this.authService = authService;
    }
    UserService = __decorate([
        Injectable(),
        __metadata("design:paramtypes", [AuthService]) // 在装饰器中，执行__metadata方法，将"design:paramtypes"和[AuthService]作为参数传递
    ], UserService);
    return UserService;
}());
console.log(Reflect.getMetadata('design:paramtypes', UserService));

```

通过上面生成的js代码，我们可以看到，当设置为`emitDecoratorMetadata: true`后，其在编译`ts`文件时，会自动在`装饰器`里面定义一个key为`design:paramtypes`，value为其依赖项的一个元数据。

这也是我们为什么在设置`emitDecoratorMetadata: true`后，无需传递参数，便可通过`Reflect.getMetadata('design:paramtypes', UserService)`直接获取到其执行类中的依赖项的原因

ok，在执行某个类之前，我们已经能到获取到对应的依赖项了。最后便是实例化创建的实现了

源码戳[这里](https://github.com/kerwin-ly/Blog/tree/master/demo/di) 大概实现代码如下：
```ts
import 'reflect-metadata';

const providers: any[] = [];
const instanceMap = new Map();

function Injectable() {
  return function (_constructor: any) {
    providers.push(_constructor);
    return _constructor;
  };
}

// 鉴权服务
@Injectable()
class AuthService {
  checkPermission(): void {
    console.log('check permission in AuthSerivce');
  }
}

// 本地存储服务
@Injectable()
class LocalStorageService {
  save(): void {
    console.log('save user in LocalStorageService');
  }
}

// 存储服务
@Injectable()
class StorageService {
  constructor(private localStorageService: LocalStorageService) {}

  save(): void {
    this.localStorageService.save();
  }
}

// 用户服务
@Injectable()
class UserService {
  constructor(
    private authService: AuthService,
    private storageService: StorageService
  ) {
    this.authService.checkPermission();
    this.storageService.save();
  }
}

// 创建实例
function create(target: any) {
  const dependencies = Reflect.getMetadata('design:paramtypes', target);
  const args = (dependencies || []).map((dep: any) => {
    if (!hasProvider(dep)) {
      throw new Error(`${dep.name} has no provider!`);
    }

    const cache = instanceMap.get(dep);
    if (cache) {
      return cache;
    }

    let instance;
    // 如果参数有依赖项，递归创建依赖项实例
    if (dep.length) {
      instance = create(dep);
      instanceMap.set(dep, instance);
    } else {
      // 参数没有依赖项，直接创建实例
      instance = new dep();
      instanceMap.set(dep, instance);
    }
    return instance;
  }) as any;
  return new target(...args);
}

// 判断需要注入
function hasProvider(dep: any): boolean {
  return providers.includes(dep);
}

create(UserService);
```

以上是`依赖注入`的简单实现，而`Angular`的实现远比这个复杂，感兴趣的可以研究下其实现源码[injector.ts](https://github.com/angular/angular/blob/master/packages/core/src/di/injector.ts)

## 三、依赖注入在Angular中的应用

在完成了一个简单的`依赖注入`后，接着我们从项目实践出发，来看`依赖注入`在`Angular`中的应用
### 自定义一个provider

某天，研发老大提了一个需求，需要实现一个`本地存储`的功能，并利用`依赖注入`使其可以在系统中任何地方调用

首先编写服务类`storage.service.ts`，实现其存储功能
```ts
// storage.service.ts
export class StorageService {
  get(key: string) {
    return JSON.parse(localStorage.getItem(key) || '{}') || {};
  }

  set(key: string, value: ITokenModel | null): boolean {
    localStorage.setItem(key, JSON.stringify(value));
    return true;
  }

  remove(key: string) {
    localStorage.removeItem(key);
  }
}
```

接着，在`user.component.ts`中尝试使用
```ts
// user.component.ts
@Component({
  selector: 'app-user',
  templateUrl: './user.component.html',
  styleUrls: ['./user.component.css']
})
export class CourseCardComponent  {
  constructor(private storageService: StorageService) {
    ...
  }
  ...
}
```

执行后 ，你会看到这样的一个错误：

```shell
NullInjectorError: No provider for StorageService!
```

显而易见，我们并没有将`StorageService`添加到 `Angular的依赖注入系统`中。`Angular`无法获取`StorageService`依赖项的`Provider`，也就无法实例化创建这个类

那么，接下来，我们便手动添加一个`Provider`。修改`storage.service.ts`文件如下

```ts
// storage.service.ts
export class StorageService {
  get(key: string) {
    return JSON.parse(localStorage.getItem(key) || '{}') || {};
  }

  set(key: string, value: any) {
    localStorage.setItem(key, JSON.stringify(value));
  }

  remove(key: string) {
    localStorage.removeItem(key);
  }
}

// 添加工厂函数，实例化StorageService
export storageServiceProviderFactory(): StorageService {
  return new StorageService();
}
```

通过上述代码，我们已经有了`Provider`。那么接下来的问题，就是如果让`Angular`每次扫描到`StorageService`这个依赖项的时候，让其去执行`storageServiceProviderFactory`方法，来创建实例

这就引出来了下一个知识点`Injection Token`

在一个服务类中，我们常常需要添加多个依赖项，来保证服务的可用。而`Injection Token`是各个依赖项的唯一标识，它让`Angular`的依赖注入系统能准确的找到各个依赖项的`Provider`。

接下来，我们手动添加一个`Injection Token`
```ts
// storage.service.ts
import { InjectionToken } from '@angular/core';

export class StorageService {
  get(key: string) {
    return JSON.parse(localStorage.getItem(key) || '{}') || {};
  }

  set(key: string, value: any) {
    localStorage.setItem(key, JSON.stringify(value));
  }

  remove(key: string) {
    localStorage.removeItem(key);
  }
}

export storageServiceProviderFactory(): StorageService {
  return new StorageService();
}

// 添加StorageServiced的Injection Token
export const STORAGE_SERVICE_TOKEN = new InjectionToken<StorageService>('AUTH_STORE_TOKEN');
```

ok，我们已经有了`StorageService`的`Provider`，也有了`StorageService`的`Injection Token`。接下来，我们需要一个配置，让`Angular`的`依赖注入系统`能够对其进行识别，在扫描到`StorageService`(Dependency)的时候，根据`STORAGE_SERVICE_TOKEN`（Injection Token）去找到对应的`storageServiceProviderFactory`(Provider)，然后实例化

```ts
// user.module.ts
@NgModule({
  imports: [
    ...
  ],
  declarations: [
    ...
  ],
  providers: [
    {
      provide: STORAGE_SERVICE_TOKEN, // 与依赖项关联的InjectionToken，用于控制工厂函数的调用
      useFactory: storageServiceProviderFactory, // 当需要创建并注入依赖项时，调用该工厂函数
      deps: [] // 如果StorageService还有依赖项，这里添加
    }
  ]
})
export class UserModule { }
```

到这里，我们完成了`依赖`的实现。最后，还需要让`Angular`知道在哪里`注入`。`Angular`提供了 `@Inject`装饰器来识别

```ts
// user.component.ts
@Component({
  selector: 'app-user',
  templateUrl: './user.component.html',
  styleUrls: ['./user.component.css']
})
export class CourseCardComponent  {
  constructor(@Inject(STORAGE_SERVICE_TOKEN) private storageService: StorageService) {
    ...
  }
  ...
}
```

到此，我们便可以在`user.component.ts`调用`StorageService`里面的方法了

### 使用类名作为Injection Token简化写法（todo标题）

emm...你是否觉得上述的写法过于复杂了，而在实际开发中，我们大多数场景是无需手动创建`Provider`和`Injection Token`的。如下：

```ts
// user.component.ts
@Component({
  selector: 'app-user',
  templateUrl: './user.component.html',
  styleUrls: ['./user.component.css']
})
export class CourseCardComponent  {
  constructor(private storageService: StorageService) {
    ...
  }
  ...
}

// storage.service.ts
@Injectable({ providedIn: 'root' })
export class StorageService {}

// user.module.ts
@NgModule({
  imports: [
    ...
  ],
  declarations: [
    ...
  ],
  providers: [StorageService]
})
export class UserModule { }
```

在`user.component.ts`，我们舍弃了`@Inject`装饰器，直接添加依赖项`private storageService: StorageService`，这得益于`Angular`对`Injection Token`的设计。

`Injection Token`不一定必须是一个`injection token object`，只要保证它在运行时环境中能够识别对应的唯一`依赖项`即可。换句话说，你可以用`类名`即运行时中的`构造函数名称`来作为`依赖项`的`injection token`。所以，我们可以省略创建`Injection Token`这一步，直接使用`类名`作为`Injection Token`

```ts
// user.module.ts
@NgModule({
  imports: [
    ...
  ],
  declarations: [
    ...
  ],
  providers: [{
    provide: StorageService, // 使用构造函数名作为Injection Token
    useFactory: storageServiceProviderFactory,
    deps: []
  }]
})
export class UserModule { }
```

注意：**由于`Angular`的依赖注入系统是在`运行时环境`中能根据`Injection Token`识别依赖项，在进行依赖注入的。所以这里不能使用`interface`名称作为`Injection Token`，因为其只存在于`Typescript`语言的编译期，并不存在于运行时中。而在运行时中，`类名`编译成了`构造函数名`，可以使用**

接下来，我们可以使用`useClass`替换`useFactory`，如下：

```ts
...
providers: [{
  provide: StorageService,
  useClass: StorageService,
  deps: []
}]
...
```

当使用`useClass`时，`Angular`会将后面的值当作一个`构造函数`，在运行时环境中，直接执行`new`指令进行实例化，这也无需我们再手动创建 `Provider`了

`useClass`还有一个特性是，`Angular`会根据`依赖项`在`Typescript`中的类型定义，作为其运行时的`Injection Token`去查找`Provider`。所以，我们也无需使用`@Inject`装饰器来告诉`Angular`在哪里注入了

你可以简写如下
```ts
  ...
  // 无需手动注入 ：constructor(@Inject(StorageService) private storageService: StorageService)
  constructor(private storageService: StorageService) {
    ...
  }
  ...

```







## 参考链接

[维基百科-控制反转](https://zh.wikipedia.org/wiki/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC)

[Angular Dependency Injection: Complete Guide](https://blog.angular-university.io/angular-dependency-injection/)

[Angular 中的依赖注入](https://angular.cn/guide/dependency-injection)

[Decorators in Typescript](https://www.typescriptlang.org/docs/handbook/decorators.html)

[如何基于 TypeScript 实现控制反转](https://zhuanlan.zhihu.com/p/311184005)

