# 堆
>完全二叉树：如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树。

堆一般用`完全二叉树`来存储。堆有两个特点:
* 结构性：用数组表示的完全二叉树；
* 有序性：任一节点的关键字是其子树的最大值（或最小值）

最大堆(MaxHeap)：任一根节点是其子树的最大值。
```
    	     56  
    	   /   \
    	  19    37 
    	 /  \   /
    	17  16 9     

   arr: [56, 19, 37, 17, 16, 9]
```

最小堆(MinHeap)：任一根节点是其子树的最小值
```
    	     5  
    	   /    \
    	  16     30
    	 /  \    /  \
    	49   40 38  39   

    arr:  [5, 16, 30, 49, 40, 38, 39]
```
![堆](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/data-structure/max-min.png)

堆的实现
```js
class Heap {
  constructor(arr) {
    this.data = arr;
    this.size = arr.length;
  }

  // 交换值
  swap(indexOne, indexTwo) {
    const tmp = this.data[indexOne];
    this.data[indexOne] = this.data[indexTwo];
    this.data[indexTwo] = tmp;
  }

  // 获取左子节点的下标
  getLeftChildIndex(i) {
    return i * 2 + 1;
  }

  // 获取右子节点的下标
  getRightChildIndex(i) {
    return i * 2 + 2;
  }

  // 获取父节点下标
  getParentIndex(childIndex) {
    return Math.floor((childIndex - 1) / 2);
  }

  hasParent(childIndex) {
    return this.getParentIndex(childIndex) !== -1;
  }

  // 构造大顶堆
  heapifyUp(customStartIndex) {
    let currentIndex = customStartIndex || this.data.length - 1;
    const parentIndex = this.getParentIndex(currentIndex);

    while (
      this.hasParent(currentIndex) &&
      this.data[parentIndex] < this.data[currentIndex]
    ) {
      this.swap(parentIndex, currentIndex);
      currentIndex = parentIndex;
    }
  }

  // 调整某节点下顺序
  // maxHeapify(i) {
  //   let max = i;
  //   if (i > this.size) {
  //     return;
  //   }
  //   let left = this.getLeftChildIndex(i);
  //   let right = this.getRightChildIndex(i);

  //   if (left < this.size && this.data[left] > this.data[max]) {
  //     max = left;
  //   }
  //   if (right < this.size && this.data[right] > this.data[max]) {
  //     max = right;
  //   }
  //   if (max === i) {
  //     return;
  //   }
  //   this.swap(i, max);
  //   return this;
  // }

  // 构建大顶堆
  // rebuildHeap() {
  //   const L = Math.floor(this.size / 2); // 第一个叶子节点

  //   for (let i = L - 1; i >= 0; i--) {
  //     this.heapifyUp(i);
  //   }
  // }

  // 插入
  add(item) {
    this.data.push(item);
    this.heapifyUp();
    return this;
  }
}
const h1 = new Heap([10, 4, 6, 7, 3, 23, 89, 45]);
h1.add(100);
h1.add(10);
h1.rebuildHeap();
console.log(h1.data);
```