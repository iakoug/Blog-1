# 详解 js 执行上下文

要了解 js 执行上下文，我们首先得从 js 引擎的执行过程说起。

js 的执行过程有以下三个阶段：

- 语法分析

- 预编译阶段

- 执行阶段

接着我们来了解下这三个阶段分别做了什么。

## 1. 语法分析

首先，js 引擎会将代码解析成`抽象语法树(AST)`，分析该 js 脚本代码块的语法是否正确，如果出现不正确，则向外抛出一个语法错误（SyntaxError），停止该 js 代码块的执行，然后继续查找并加载下一个代码块；如果语法正确，则进入预编译阶段。（这不是本文的重点，就不细说下去了）
![语法错误]](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/js/syntax-error.png)

## 2. 预编译阶段

进入预编译阶段，js 引擎会根据当前的可执行代码创建对应的`执行上下文`。接下来，我们来看看有哪些类型的执行上下文？

### 2.1 执行上下文的类型

`执行上下文`的类型有三种：

- 全局执行上下文：仅有一个。当 js 代码被加载完后进入预编译期，即进入了全局环境，创建全局执行上下文，`this`指向全局对象

- 函数执行上下文：存在多个。每当函数**被调用**时候才会被创建，每次调用函数都会创建一个新的`执行上下文`

- evel 函数执行上下文：运行在`eval`函数中的代码

了解完`执行上下文`的类型后，我们知道了`执行上下文`存在多个。那么它是如何被保存的呢？

### 2.2 执行上下文栈

`执行上下文栈（Execution context stack，ECS）`也叫做`调用栈`，用于存储代码执行过程中创建的所有`执行上下文`。

当 javascript 开始解释执行时，其首先遇到的就是`全局环境`，所以将`全局执行上下文`压入栈中。

然后继续执行，在执行一个函数时，会继续创建一个新的`函数执行上下文`，并压入栈中。当该函数执行完毕，再从栈顶中弹出。

执行期间，如果函数中还有函数需要执行，会继续创建新的`函数执行上下文`并逐个压入栈中。

具体流程如下图：

![执行上下文栈]](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/js/context-stack.jpeg)

了解完了`执行上下文栈`是如何处理`执行上下文`的，接下来，我们来了解下`执行上下文`的属性

### 2.3 执行上下文的属性

一个`执行上下文`有三个重要的属性：

- 变量对象（Variable Object）

- 作用域链（Scope chain）

- this

每创建一个`执行上下文`都需要如下的三个步骤：

- 1. 创建变量对象

- 2. 建立作用域链

- 3. 确定当前执行上下文的 this 指向

下面，我们对上述提到的三个属性进行解释：

#### 2.3.1 变量对象

通俗的说，`变量对象`是与执行上下文相关的**数据作用域**，存储了在上下文中定义的**变量**和**函数声明**。

全局执行上下文的`变量对象`就是**全局对象**（在浏览器中是`window对象`），在顶层 JavaScript 代码中，可以用关键字 this 引用全局对象。因为全局对象是作用域链的头，这意味着所有非限定性的变量和函数名都会作为该对象的属性来查询。

函数执行上下文的`变量对象`包括：

- 函数的所有形参。包括参数对象的属性和属性值。(注意：`变量对象`中实参为`undefined`)

- 函数声明。由名称和对应值组成的函数对象（function-object）作为其`变量对象`的一个属性，如果变量对象中已经存在相同名称的属性，则完全替换。（注意：函数声明优先级高于变量声明。可以用下面代码进行测试，输出的是 foo 函数，而不是 undefined）

```js
console.log(foo); // 输出 function foo
var foo = 'foo1';
function foo() {}
```

- 变量声明。由名称和对应值(注意此时的值是`undefined`)组成的一个变量对象被创建。

最后，总结一下创建`变量对象`的过程：

1. 如果是函数执行上下文，则创建 arguments 对象，并创建形参（注意还没有实参）

2. 函数声明提前

3. 变量声明提前，设置属性值为`undefined`

#### 2.3.2 建立作用域链

作用域链是指：当查找变量时，会先从当前变量对象中查找，如果没有查找到，则查找 “父级变量对象”。以此循环，一直找到全局变量对象，即全局对象为止。这样由多个执行上下文的变量对象构成的链表就叫做`作用域链`。

作用域链的第一项永远是当前作用域（当前上下文的变量对象或活动对象）；最后一项永远是全局作用域（全局执行上下文的活动对象）；

下面，我们通过一个例子来说明

```js
var name = 'kerwin';
function foo() {
  console.log(name); // 输出kerwin
}
foo();
```

在 foo 函数作用域中，没有属性为 name 的变量对象。那么就从它的上一层代码中查找，这时候找到了全局对象声明了`name`。则将全局对象中的 name 进行返回 。

- 知道了`作用域链`后，我们来了解一下，“函数变量对象”是如何查找“父级变量对象”的呢？

- 因为函数在创建时，内部有一个`[[scope]]`属性会将所有父级变量对象保存到其中。也就存储了上层的所有层级链。

**词法作用域和动态作用域**

众所周知，js 采用的是`词法（静态）作用域`，其作用域在定义函数的时候就确定了。（补充：相反的是`动态作用域`，其在函数执行时候才确定作用域。如:bash）

下面，我们通过一个例子来说明`词法作用域`和`动态作用域`的区别

```js
var value = 1;

function foo() {
  console.log(value);
}

function bar() {
  var value = 2;
  foo();
}

bar();
```

如果是`词法作用域`，在执行到`console.log(value)`时，由于当前 foo 函数内部不存在`value`，则在**函数声明位置**所在的作用域中查找，返回结果为 1。

如果是`动态作用域`，同样在 foo 函数没找到`value`，向**函数执行**所在的作用域中查找，也就是 bar 函数中，返回结果为 2。

#### 2.3.3 确定当前执行上下文的 this 指向

全局执行上下文：`this`指向全局对象，浏览器中指向`window`，node环境中指向`global`

函数执行上下文：指向函数的调用者。（也可以通过call/apply/bind方法改变this指针）

## 3. 执行阶段
