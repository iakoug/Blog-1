# JavaScript隐式转换

JavaScript在参与运算`+`、`-`、`*`、`/`、`==`、`>`、`<`时，当两侧类型不一致时，会进行`隐式转换`。

## 等于运算符（==）

在JavaScript中判断两个值是否相等，可以用`等于运算符（==）`和`严格相等运算符（===）`。

`等于运算符（==）`检查其两个元素是否相等，并返回Boolean结果。与`严格相等运算符（===）`不同，它会尝试强制类型转换并且比较不同类型的操作数。

严格相等运算符比较时，**当两个操作数类型不同，则认为不相等。不会对类型进行转换。**

也就是说，当类型不同的时候，`==`会进行`隐式转换`。比如：

```js
'1' == 1; // true
0 == false; // true
null == undefined; // true
```

下面我们来看几种操作数比较：

* 对象和对象：会比较两个对象的**引用**是否相同

```js
{} == {}; // false，两个空对象的引用不同
var a = b = {};
a == b; // true，指向同一个空对象
```

* null和undefined：**返回true**，都表示空

```js
null == undefined; // true
```

* 数字和字符串：先将字符串转换为数字，再比较

```js
0 == ''; // true，先将''转换为数值0，然后比较0 == 0
```

* 布尔和其他值：**先将Boolean转换为Number类型**，再比较（true转换为1，false转换为0）

```js
true == '2'; // false，先将true转换为数值类型为1，然后比较 1 == '2'，再将'2'转换为数字，最终 1 == 2。
```

* 对象和数值/字符串：调用对象的`valueOf()`和`toString()`方法将对象转换为原始值，再进行比较。

```js
'1,2,3' == [1, 2, 3]; // true，先调用valueOf，将数组对象转换为原始值，得到结果'1,2,3'。'1,2,3' == '1,2,3'
```

这里补充介绍下`valueOf`和`toString()`：

`valueOf`和`toString()`方法都是在操作符中一边是对象时，自动触发的。

// TODO 介绍valueOf和toString方法

最后我们再来看一道综合的面试题：
```js
[] == ![]; 
```

首先，由于前面有个`取反操作符 !`，所以先将`[]`转换为Boolean值，即：Boolean([])，结果为`true`。（使用Boolean转换一个对象，只有null和undefined是false,其余为true）。然后再取反，`!true`结果为`false`。

所以，我们接着比较等号两侧：`[] == false`

当操作符一侧是对象时，我们先将对象转换为基础值。这里是一个数组，通过`valueOf()`方法返回的仍然是一个数组，接着调用`toString()`方法，`[].toString()`返回一个空字符串。所以这里得到操作符两侧的结果为：`'' == false`

当Boolean和其他值比较时，Boolean值先被转换为Number，所以操作符更新为：`'' == 0`

最后，当字符串和数值比较时，字符串会被转换为数值类型。`Number('')`的结果为0，所以最终操作符两侧为`0 == 0`，答案为true。

## 总结
