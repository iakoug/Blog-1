# 闭包的理解

什么是闭包？

下面有几种解释：

[MDN-闭包](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures)：

> 一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）

《JavaScript 权威指南》：

> 从技术的角度讲，所有的 JavaScript 函数都是闭包。

[冴羽大佬](https://github.com/mqyqingfeng/Blog/issues/9)：

> 在技术实践中，闭包是指 在代码中引用了自由变量（自由变量是指：函数中使用的变量，既不是函数参数也不是函数作用域中的变量）。即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）

下面我们来对闭包进行理解：

首先来分析下下面代码的执行过程：

```js
var scope = 'global scope';
function checkscope() {
  var scope = 'local scope';
  function f() {
    return scope;
  }
  return f;
}

var foo = checkscope();
foo();
```

1. 进入全局环境，创建执行上下文，全局执行问被压入到执行上下文栈

2. 全局执行上下文初始化

3. 执行 checkscope 函数，创建 checkscope 函数执行上下文，压入到执行上下文栈中

4. 初始化 checkscope 函数执行上下文栈，创建变量对象、this 和作用域等

5. checkscope 函数执行完毕，从执行上下文栈中 pop 出该函数执行上下文

6. 执行 f 函数，创建 f 函数执行上下文，压入到执行上下文栈中

7. 初始化 f 函数执行上下文栈，创建变量对象、this 和作用域等

8. f 函数执行完毕，从执行上下文栈中 pop 出该函数执行上下文

代码执行结果：return 字符串"local scope"。

这里大家可能有个疑问？我们在上述第 5 步时，checkscope 的执行上下文已经从栈中弹出了（意味着该函数执行上下文已经被销毁），那么最后执行 foo()方法的时候，为什么还能返回 scope 的值呢？

这就是`闭包`。闭包是由函数和声明该函数的词法环境组成，该环境包含了这个闭包创建时作用域内的所有局部变量。

由于上述代码 checkscope 函数中，将函数 f 作为了一个值返回，这个 f 维持了该词法环境的引用，或者说 f 是一个可访问该词法环境的一个“通道”。而将 f 赋值给 foo 后，那么 foo 函数也有了该词法环境的引用，而词法环境中有该作用域的所有局部变量，所以就可以正常访问 scope 变量。

### 闭包的经典使用场景

```html
<html>
  <body>
    <div>1</div>
    <div>2</div>
    <div>3</div>
    <div>4</div>
    <div>5</div>
    <script>
      var nodes = document.getElementsByTagName('div');
      for (var i = 0, len = nodes.length; i < len; i++) {
        nodes[i].onclick = function () {
          alert(i);
        };
      }
    </script>
  </body>
</html>
```

测试这段代码就会发现，无论点击哪个 div，最后弹出的结果都是 5。这是因为 div 节点的 onclick 事件是被异步触发的，当事件被触发的时候，for 循环早已结束，此时变量 i 的值已经是 5，所以在 div 的 onclick 事件函数中顺着作用域链从内到外查找变量 i 时，查找到的值总是 5。

解决方法是在闭包的帮助下，把每次循环的 i 值都封闭起来。当在事件函数中顺着作用域链 中从内到外查找变量 i 时，会先找到被封闭在闭包环境中的局部变量（函数参数） i，如果有 5 个 div，这里的 i 就分别 是 0,1,2,3,4:

```ts
for (var i = 0, len = nodes.length; i < len; i++) {
  (function (i) {
    nodes[i].onclick = function () {
      console.log(i);
    };
  })(i);
}
```

### 闭包与内存管理

首先，明确一个概念。闭包并不意味着内存泄漏，这跟 JS 本身没有任何关系。

局部变量本来应该在函数退出的时候被解除引用，但如果局部变量被封闭在闭包形成的环境中，那么这个局部变量就能一直生存下去。从这个意义上看，闭包的确会使一些数据无法被及时销毁。使用闭包的一部分原因是我们选择主动把一些变量封闭在闭包中，因为可能在以后还需要使用这些变量，**把这些变量放在闭包中和放在全局作用域，对内存方面的影响是一致的，这里并不能说成是内存泄露**。如果在将来需要回收这些变量，我们可以手动把这些变量设为 null，该变量就会在下一次垃圾回收时被清理掉。

跟闭包和内存泄露有关系的地方是，**使用闭包的同时比较容易形成循环引用**。在 早期的 IE6 浏览器中，由于 BOM 和 DOM 中的对象是使用 C++以 COM 对象 的方式实现的，而 COM 对象的垃圾收集机制采用的是`引用计数策略`。在基于引用计数策略的垃圾回收机制中，如果两个对象之间形成了循环引用，那么这两个对象都无法被回收，但循环引用造成的内存泄露在本质上也不是闭包造成的。
