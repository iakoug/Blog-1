### 239. 滑动窗口最大值(困难)

> LeetCode 地址：https://leetcode-cn.com/problems/sliding-window-maximum/

### 题解

本体是一道经典的`单调队列`题目。通过构造`单调递减队列`，每次滑动窗口的最大值，其实就是`队头`元素。

在操作单调队列的过程中，需要注意下面两点：

**如何 push 能保证队列的单调递减性？**

如果`队列的尾部元素`比`当前值` 小，为保证队列的单调递减性质。将队尾元素移除，继续比较新的队尾元素。直到`队尾元素`比当前值大为止。最后将当前值添加到队尾。

**什么时候移除队头的元素？**
当滑动窗口往右移动时，如果**窗口移除的元素等于队列中的队头元素**（即上一次滑动窗口的最大值），则需要将队头元素移除。

**什么时候操作队列和结果数组？**
当开始遍历数组时，我们就需要操作队列。当 i(遍历次数) = 滑动窗口的长度 - 1 时，说明已经遍历完第一个滑动窗口的区间，开始求区间的最大值。从 i 开始，一直到 nums.length-1，后续的每一次都需要计算。

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var maxSlidingWindow = function (nums, k) {
  const queue = []; // 单调递减队列
  const result = []; // 结果数组

  for (let i = 0; i < nums.length; i++) {
    let front = queue[0]; // 队列头部元素

    // 如果滑动窗口移动时，移除的元素刚好是上个滑动窗口的最大值，则将队列头部的值弹出
    if (nums[i - k] === front) {
      queue.shift();
    }
    // 将队列尾部元素与当前元素比较，如果当前元素比队尾元素大，则移出队尾元素。直到当前元素比队尾元素小为止
    // 这样做是为了保证队列的单调递减
    while (queue[queue.length - 1] < nums[i]) {
      queue.length--;
    }
    queue.push(nums[i]); // 将当前元素插入队尾
    // 如果遍历到i时，已达到滑动窗口的尾部。说明一次滑动窗口区间的值已经处理完，向结果数组中添加当前窗口的最大值
    if (i >= k - 1) {
      result.push(queue[0]); // 将最大元素放入结果中
    }
  }
  return result;
};
```
