### 146. LRU 缓存(中等)

> LeetCode 地址：https://leetcode-cn.com/problems/lru-cache/

### 题解

本题的关键点在于**get 和 put 必须以 O(1) 的平均时间复杂度运行**

在我们常见的数据结构中，通过`哈希表`数据结构查找/插入元素的时间复杂度是`O(1)`。但题目中提到

> 如果插入操作导致关键字数量超过 capacity ，则应该 逐出 **最久未使用**的关键字

什么是“最久未使用”？

我们可以简单的理解，设计的`LRUCache`还需要时间**顺序**的概念。如果一个元素被访问了，那么它应该被标记为最新，然后根据“新旧程度”进行排序。

但哈希表没有顺序的概念，是直接通过索引访问的。

那么考虑到这个因素，在一个线性结构中，插入的时间复杂度为`O(1)`的，很容易想到`链表`。

考虑到下面三个特性，我们有两种方法来解题

- 特性 1：查找元素的时间复杂度为 O(1)

- 特性 2：插入元素的时间复杂度为 O(1)

- 特性 3：元素有序性（根据访问的时间排序，当插入元素达到上限后，删除一个“最久未使用的”元素）

**方法一：Map 实现**

es6 推出的`Map`刚好能满足我们上面的三种特性。特性 1 和特性 2 很明显，通过索引访问即可。

针对特性 3，在`Map`中调用`set(key, value)`方法，**每次都会插入到末尾**。所以，我们把末尾的元素当作最新的，最旧的元素在头部。

通过`Map.keys()`方法返回一个有序的（按`set()`插入顺序）`MapIterator`。然后通过调用`next()`方法从头到尾逐个获取元素。

```js
/**
 * @param {number} capacity
 */
var LRUCache = function (capacity) {
  this.map = new Map();
  this.maxSize = capacity;
};

/**
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function (key) {
  const value = this.map.get(key);
  if (value !== undefined) {
    // 更新key的位置
    this.map.delete(key); // 从当前位置删除
    this.map.set(key, value); // 添加到末尾位置
    return value;
  }
  return -1;
};

/**
 * @param {number} key
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function (key, value) {
  // 如果key已存在，直接修改
  if (this.map.has(key)) {
    this.map.delete(key); // 从当前位置删除
    this.map.set(key, value); // 添加到末尾位置
    return;
  }
  // 如果key不存在，且当前size已经达到上限
  if (this.map.size >= this.maxSize) {
    // map.keys()返回的是一个MapIterator对象，可以通过next()逐个获取item项，返回{value: xx, done: false/true}
    const removeItem = this.map.keys().next(); // 删除Map的第一个item，就是最久没用的item
    this.map.delete(removeItem.value); // 删除Map头部的项
    this.map.set(key, value); // 添加到Map末尾
    return;
  }
  this.map.set(key, value);
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * var obj = new LRUCache(capacity)
 * var param_1 = obj.get(key)
 * obj.put(key,value)
 */
```

**方法二：哈希表 + 双向链表解题**

如果不使用`Map`的特性，我们就需要构建一个`LinkedHashMap`
```js

```
