### 32. 最长有效括号(困难)

> LeetCode 地址：https://leetcode.cn/problems/longest-valid-parentheses/

### 题解

这道题对个人而言，是一定要跳出自己的思维惯性。之前做的大多数题目，如：爬楼梯、斐波那契数列等。都可以通过相邻的 dp 数组的值直接推断出当前值。但在该题中，我们需要分不同情况。**dp[i - 1]并不能直接推断出当前的 dp[i]，但它提供了一个“桥梁”。让我们可以**

- 确定 dp 数组和下标

根据题目，我们将 dp[i]定义为：下标为 i 时，最长有效括号的长度为 dp[i]

- 确定状态转移方程和初始值

1. 当`s[i] === '('`时：此时一定无法构成有效括号，`dp[i] = 0`；

2. 当`s[i] === ')'`时，分不同情况

2.1 当`s[i] === ')' && s[i - 1] === '('`时，此时能构成最长有效括号。`dp[i] = dp[i - 2] + 2 (i >= 2)`

2.2 当`s[i] === ')' && s[i - dp[i - 1] - 1] === '('`时，此时能构成最长有效括号，如：()(())。这道题的难点就在于此。

`dp[i - 1]`表示其构成的最长有效括号长度。`i - dp[i - 1]`就到达了`dp[i - 1]`最长有效括号的起始位置。**如果它的上一个位置`i - dp[i - 1] - 1`是左括号，那么此时一定能和当前 s[i]构成有效括号的。**

接着，我们思考如何计算当前的`dp[i]`。这里很容易想到结果：`dp[i] = dp[i - 1] + 2`。但这是并没有考虑完所有情况，如：括号()(())，我们得到的结果应该是 4，而正确结果是 6。我们还需要计算最前面的括号`()`(())。它的下标是`i - dp[i - 1] - 2`。

所以，这种情况的最终结果应该由三部分组成：最新组成的有效括号长度 2 + dp[i -1] + 形成最新有效括号的左括号的上一个位置的有效括号长度。

即： dp[i] = `2` + `dp[i - 1]` + `dp[i - dp[i - 1] - 2]`

动态转移方程如下：

```js
// 当前位置为左括号，肯定无法形成括号
if (s[i] === '(') {
    dp[i] = 0;
    continue;
}
// 当前位置为右括号，且s[i - 1]为左括号
if (s[i] === ')' && s[i - 1] === '(') {
    if (i >= 2) {
        dp[i] = dp[i - 2] + 2;
    } else {
        dp[i] = 2;
    }
}
// 当前位置为右括号，且组成dp[i-1]的起始位置的前一个元素是左括号
else if (s[i] === ')' && s[i - dp[i - 1] - 1] === '(') {
    let preIndex = i - dp[i - 1] - 2 ; // 最近未匹配的左括号的位置的上一个位置
    dp[i] = dp[preIndex >= 0 ? preIndex : 0] + dp[i - 1] + 2;
}
```

- 确定遍历顺序

当 s[i] === '('时，一定无法构成括号

最终代码如下：

```js
/**
 * @param {string} s
 * @return {number}
 */
var longestValidParentheses = function (s) {
  let dp = new Array(s.length).fill(0);
  let max = 0;

  for (let i = 1; i < s.length; i++) {
    // 当前位置为左括号，肯定无法形成括号
    if (s[i] === "(") {
      dp[i] = 0;
      continue;
    }
    // 当前位置为右括号，且s[i - 1]为左括号
    if (s[i] === ")" && s[i - 1] === "(") {
      if (i >= 2) {
        dp[i] = dp[i - 2] + 2;
      } else {
        dp[i] = 2;
      }
    }
    // 当前位置为右括号，且组成dp[i-1]的起始位置的前一个元素是左括号
    else if (s[i] === ")" && s[i - dp[i - 1] - 1] === "(") {
      let preIndex = i - dp[i - 1] - 2; // 最近未匹配的左括号的位置的上一个位置
      dp[i] = dp[preIndex >= 0 ? preIndex : 0] + dp[i - 1] + 2;
    }
    max = dp[i] > max ? dp[i] : max;
  }
  return max;
};
```
