### 96. 不同的二叉搜索树

> 题目地址：https://leetcode.cn/problems/unique-binary-search-trees/

### 题解

首先，我们定义 dp 数组，`dp[i]`表示：数字为`i`时，二叉搜索树的种数为`dp[i]`

我们从 n 为 1 开始分析，来寻找规律。

当 n 为 1。根节点只能为 1，左右子节点个数为 0。

当 n 为 2。根节点为 1 时，左节点个数为 0（i - 1，i 表示根节点），右节点个数为 1（n - i）。根节点为 2 时，左节点个数为 1，右节点个数为 0。

所以，分别计算出 **i（i 的值为 1,2,3...n）为根节点的二叉搜索树种类 = 左子树的节点个数 \* 左子树的节点个数** （注意：这里左子树个数和右子树个数是**相乘**计算总数，而不是相加。它们是多对多的关系。）。然后求和。即可得到输入数字 n，得到的二叉搜索树种类总数。

假设n个节点存在二叉排序树的个数是G(n)，公式`G(n) = G(0) * G(n - 1) + G(1) * G(n - 2) + ... G(n - 2) * G(1) + G(n - 1) * G(0)`

注意，题目中提示`n >= 1`。但上面公式中出现了G(0)，这超出边界值，我们不能想当然的认为0个节点构成的二叉树种类为0。否则，`G(0) * G(n - 1)`结果都是0。实际它的结果应该是`G(n - 1)`才对。所以，**G(0) = 1**。

这里也提醒了我们，在定义边界之外的值时，不能想当然的把它当作正常条件去考虑。而是需要根据公式或题目意思去反向推断出来。

```js
/**
 * @param {number} n
 * @return {number}
 */
var numTrees = function (n) {
  let dp = new Array(n + 1).fill(0);
  dp[0] = 1; // 题目中n >= 1，这里初始化为0的情况是便于计算，无实际意义
  dp[1] = 1;

  for (let i = 2; i <= n; i++) {
    for (let j = 1; j <= i; j++) {
      dp[i] += dp[j - 1] * dp[i - j]; // 注意求某个根节点的总数，是多对多关系，相乘
    }
  }
  return dp[n];
};
``;
```
