# 回溯算法

回溯法也可以叫做回溯搜索法，它是一种搜索的方式。

在之前的二叉树题目中，我们便用到过回溯的思想，如：[二叉树的所有路径](<https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/257.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84(%E7%AE%80%E5%8D%95).md>)。可以看出，回溯和递归是相辅相成的

回溯算法的本质是**穷举**，所以效率不是太高。如果需要优化，只能在其穷举基础上做一些**剪枝**操作。

在解题中，我们可以把所有的回溯问题，都抽象为一颗树形结构来考虑。如在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度构成的树的深度。

## 相关题目

### 组合问题

[77. 组合(中等)](https://github.com/kerwin-ly/Blog/blob/master/algorithm/backtracking/77.%20%E7%BB%84%E5%90%88(%E4%B8%AD%E7%AD%89).md)

[216. 组合总和 III(中等)]()

[40. 组合总和 II(中等)]()

### 排列问题

[46. 全排列(中等)](https://github.com/kerwin-ly/Blog/blob/master/algorithm/backtracking/46.%20%E5%85%A8%E6%8E%92%E5%88%97(%E4%B8%AD%E7%AD%89).md)

### 分割问题
[131. 分割回文串]()

[93.复原 IP 地址(中等)]()

## 总结
在完成了一系列回溯算法的题目后，我们对回溯算法进行如下总结：

**在分析回溯算法的题目时，一定要将其抽象成一颗树形结构来考虑。** 通过该树形结构，我们可以更方便的看出正确的执行流程，从而帮助我们去确定递归的参数、递归终止条件和单层逻辑的执行等。

回溯算法和递归的思路类似，主要是分三步骤：

**1. 确定递归的参数和返回值（返回值一般都是void）**

**2. 确定递归终止条件**

**3. 确定递归单层逻辑，递归后面需要回溯**

### 回溯算法的通用模板

通过上面的解题思路，我们可以得到一个通用的解题模板，伪代码如下：

```js
function backtracking(参数) {
    if (终止条件) {
        存储结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}

```
