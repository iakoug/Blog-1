# 闭包

>闭包的形成与其变量的作用域和生存周期密切相关

### 变量的作用域

当在函数中声明一个变量的时候，如果该变量前面没有带上关键字 var，这个变量就会成为 全局变量。另外一种情况是用 var 关键字在函数中声明变量，这时候的变量即是局部变量，只有在该函 数内部才能访问到这个变量，在函数外面是访问不到的。如果希望在外部访问，则需要用到闭包了。

```ts
var func = function(){ var a = 1; }
alert ( a ); // 输出: 1 };
func();
alert ( a ); // 输出:Uncaught ReferenceError: a is not defined
```

### 变量的生存周期

对于全局变量来说，其生存周期是永久的，除非主要销毁。而对于在函数内用 var 关键字声明的局部变量来说，当退出函数时，这些局部变量即失去了 它们的价值，它们都会随着函数调用的结束而被销毁

```ts
var func = function(){
var a = 1; // 退出函数后局部变量 a 将被销毁 alert ( a );
}; func();
```

### 闭包的经典使用场景

```html
<html> <body>
<div>1</div> <div>2</div> <div>3</div> <div>4</div> <div>5</div>
<script>
var nodes = document.getElementsByTagName( 'div' );
for ( var i = 0, len = nodes.length; i < len; i++ ){ nodes[ i ].onclick = function(){
alert ( i ); }
};
</script> </body>
</html>
```
测试这段代码就会发现，无论点击哪个 div，最后弹出的结果都是 5。这是因为 div 节点的 onclick 事件是被异步触发的，当事件被触发的时候，for 循环早已结束，此时变量 i 的值已经是 5，所以在 div 的 onclick 事件函数中顺着作用域链从内到外查找变量 i 时，查找到的值总是 5。
解决方法是在闭包的帮助下，把每次循环的 i 值都封闭起来。当在事件函数中顺着作用域链 中从内到外查找变量 i 时，会先找到被封闭在闭包环境中的 i，如果有 5 个 div，这里的 i 就分别 是 0,1,2,3,4:
```ts
for ( var i = 0, len = nodes.length; i < len; i++ ){ (function( i ){
nodes[ i ].onclick = function(){ console.log(i);
} })( i )
};
```

### 闭包与内存管理
局部变量本来应该在函数退出的时候被解除引用，但如果局部变量被封闭在闭包形成的环境 中，那么这个局部变量就能一直生存下去。从这个意义上看，闭包的确会使一些数据无法被及时 销毁。使用闭包的一部分原因是我们选择主动把一些变量封闭在闭包中，因为可能在以后还需要 使用这些变量，把这些变量放在闭包中和放在全局作用域，对内存方面的影响是一致的，这里并 不能说成是内存泄露。如果在将来需要回收这些变量，我们可以手动把这些变量设为 null。

跟闭包和内存泄露有关系的地方是，使用闭包的同时比较容易形成循环引用，如果闭包的作 用域链中保存着一些 DOM 节点，这时候就有可能造成内存泄露。但这本身并非闭包的问题，也并非 JavaScript 的问题。在 IE 浏览器中，由于 BOM 和 DOM 中的对象是使用 C++以 COM 对象 的方式实现的，而 COM 对象的垃圾收集机制采用的是引用计数策略。在基于引用计数策略的垃圾回收机制中，如果两个对象之间形成了循环引用，那么这两个对象都无法被回收，但循环引用
造成的内存泄露在本质上也不是闭包造成的。
