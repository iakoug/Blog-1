# 树结构
>一般用于存储层级的数据结构，有明确的所属关系。

#### 基本概念

```
    	    8  （8是根节点）
    	   /  \
    	  6   10 （10是9和11的父节点）
    	 /    / \
    	5    9  11 （9是10的左子节点，11是10的右子节点）
    （5，9，11是这颗树的叶子节点）     
```

儿子兄弟表示法表示树结构
![儿子兄弟表示法](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/tree-son-bro.png)

* 二叉树：在使用`儿子兄弟法`表示树结构后，旋转其45度，便可很明显的看到一个`二叉树`的结构（二叉树：一个节点中最多含有2个子节点）。所以**任何一个树都可以用二叉树进行表示**
![二叉树](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/binary-tree.png)

* 二叉搜索树：它是一个二叉树，可以为空。同时需要满足几个特性。**非空左子树的所有键值小于其根节点的键值**；**非空右子树的所有键值大于其根节点的键值**；**左右子树本生也是二叉搜索树**。其可以高效的查找目标节点。（二分法查找底层实际就是二叉搜索树的构建）
![二叉搜索树](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/binary-search-tree.png)

#### 二叉搜索树的遍历

**先序遍历**：访问根节点 => 先序遍历其左子树 => 先序遍历其右子树（实现参考下面代码）。如图
![先序遍历](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/binary-tree-first-order.png)

**中序遍历**：中序遍历其左子树 => 访问根节点 => 中序遍历其右子树（实现参考下面代码）。如图
![中序遍历](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/binary-tree-middle-order.png)

**后序遍历**：后序遍历其左子树 => 后序遍历其右子树 => 访问根节点（实现参考下面代码）。如图
![后序遍历](https://raw.githubusercontent.com/kerwin-ly/Blog/master/assets/imgs/binary-tree-middle-order.png)

使用链表封装二叉搜索树
```js
function BinarySearchTree() {
  // 属性
  this.root = null;

  // 内部类
  function Node(key, value) {
    this.key = key;
    this.value = value;
    this.left = null;
    this.right = null;
  }

  // 对外暴露insert方法
  BinarySearchTree.prototype.insert = function (key, value) {
    // 创建节点
    var newNode = new Node(key, value);

    // 判断根节点是否有值
    if (this.root === null) {
      this.root = newNode;
      return;
    }

    this._insertNode(this.root, newNode);
  };

  // 私有方法，二叉树匹配，插入到对应位置
  BinarySearchTree.prototype._insertNode = function (node, newNode) {
    // 新节点比原节点key值更大，对右边的树节点进行比较
    if (node.key < newNode.key) {
      if (node.right === null) {
        node.right = newNode;
        return;
      }
      this._insertNode(node.right, newNode);
    } else {
      if (node.left === null) {
        node.left = newNode;
        return;
      }
      this._insertNode(node.left, newNode);
    }
  };

  // 先序遍历
  BinarySearchTree.prototype.preOrderTraversal = function (handler) {
    _preOrderTraversalNode(this.root, handler);
  };

  function _preOrderTraversalNode(node, handler) {
    if (!node) return;

    // 这里的执行顺序，类似 洋葱模型
    handler(node.key);
    // 一直查找到最底层的左节点
    _preOrderTraversalNode(node.left, handler);
    // 根据调用栈，从最底层开始查找右节点
    _preOrderTraversalNode(node.right, handler);
  }

  // 中序遍历
  BinarySearchTree.prototype.midOrderTraversal = function (handler) {
    _midOrderTraversalNode(this.root, handler);
  };

  // 私有方法，递归调用中序遍历方法
  function _midOrderTraversalNode(node, handler) {
    if (!node) return;

    _midOrderTraversalNode(node.left, handler);
    handler(node.key);
    _midOrderTraversalNode(node.right, handler);
  }

  // 后序遍历
  BinarySearchTree.prototype.postOrderTraversal = function (handler) {
    _postOrderTraversalNode(this.root, handler);
  };

  function _postOrderTraversalNode(node, handler) {
    if (!node) return;

    _postOrderTraversalNode(node.left, handler);
    _postOrderTraversalNode(node.right, handler);
    handler(node.key);
  }

  // 最小值
  BinarySearchTree.prototype.min = function () {
    let node = this.root;
    let key = null;

    while (node) {
      key = node.key;
      node = node.left;
    }
    return key;
  };

  // 最大值
  BinarySearchTree.prototype.max = function () {
    let node = this.root;
    let key = null;

    while (node) {
      key = node.key;
      node = node.right;
    }
    return key;
  };

  // 获取特定的值
  BinarySearchTree.prototype.search = function (key) {
    return _searchNode(this.root, key);
  };

  function _searchNode(node, key) {
    if (!node) return false;

    if (key < node.key) {
      return _searchNode(node.left, key);
    } else if (key > node.key) {
      return _searchNode(node.right, key);
    } else {
      return node.key;
    }
  }

  // 删除操作
  BinarySearchTree.prototype.remove = function (key) {
    let parent = null;
    let current = this.root;

    // 获取需删除的节点 current
    while (key !== current.key) {
      parent = current;
      if (key < current.key) {
        current = current.left;
      } else if (key > current.key) {
        current = current.right;
      }
      if (!current) return false;
    }

    // 判断是否删除的是根节点
    if (this.root.key === key) {
      this.root = null;
    } else {
      // 逻辑处理，replace节点替换current节点

      // 左右节点为空
      if (!current.left && !current.right) {
        if (current.key < parent.key) {
          parent.left = null;
        } else {
          parent.right = null;
        }
      } else if (current.left && !current.right) {
        // 左节点存在，右节点为空
        if (current.key < parent.key) {
          parent.left = current.left;
        } else {
          parent.right = current.left;
        }
      } else if (!current.left && current.right) {
        // 左节点为空，右节点存在
        if (current.key < parent.key) {
          parent.left = current.right;
        } else {
          parent.right = current.right;
        }
      } else {
        // 左右子节点均存在
        const replaceNode = getSuccessor(current);

        // 判断删除节点是 在 parent的左子节点 or 右边子节点
        if (current.key < parent.key) {
          parent.left = replaceNode;
        } else {
          parent.right = replaceNode;
        }
        replaceNode.right = current.right;
      }
    }
  };

  /**
   * 获取先驱 节点
   * 前驱：比current小一点点的节点称为前驱，其是current节点左子树的最大值
   * 后继：比current大一点点的节点称为后继，其是current节点右子树的最小值
   * @param {*} delNode
   * @returns
   */
  function getSuccessor(delNode) {
    let replaceNode = delNode.left; // 先驱节点
    let successorParent = delNode; // 先驱节点的父节点

    while (replaceNode.right) {
      successorParent = replaceNode;
      replaceNode = replaceNode.right;
    }

    if (replaceNode !== delNode.left) {
      successorParent.right = replaceNode.left; // 如果“替换节点”的左节点存在，则挂载到其父节点的右节点上
      replaceNode.left = delNode.left;
    }

    return replaceNode;
  }
}

const tree = new BinarySearchTree();
let result = '';
let midResult = '';
let endResult = '';

tree.insert(9, 9);
tree.insert(8, 8);
tree.insert(4, 4);
tree.insert(13, 13);
tree.insert(12, 12);
tree.insert(15, 15);
tree.insert(5, 5);
tree.insert(6, 6);
tree.insert(10, 10);
tree.insert(11, 11);
tree.insert(14, 14);
tree.insert(16, 16);

tree.remove(15);

tree.preOrderTraversal(function (key) {
  result += `-${key}`;
});

tree.midOrderTraversal(function (key) {
  midResult += `-${key}`;
});

tree.postOrderTraversal(function (key) {
  endResult += `-${key}`;
});

console.log('先序遍历结果：', result);
console.log('中序遍历结果：', midResult);
console.log('后序遍历结果：', endResult);
console.log('最小值：', tree.min());
console.log('最大值：', tree.max());
console.log('搜索 10，结果为：', tree.search(10));
console.log('搜索 5，结果为：', tree.search(5));

```